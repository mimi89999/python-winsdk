// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.SmartCards.h"


namespace py::cpp::Windows::Devices::SmartCards
{
    struct module_state
    {
        PyObject* type_SmartCardActivationPolicyChangeResult;
        PyObject* type_SmartCardAppletIdGroupActivationPolicy;
        PyObject* type_SmartCardAutomaticResponseStatus;
        PyObject* type_SmartCardCryptogramAlgorithm;
        PyObject* type_SmartCardCryptogramGeneratorOperationStatus;
        PyObject* type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat;
        PyObject* type_SmartCardCryptogramMaterialPackageFormat;
        PyObject* type_SmartCardCryptogramMaterialProtectionMethod;
        PyObject* type_SmartCardCryptogramMaterialType;
        PyObject* type_SmartCardCryptogramPlacementOptions;
        PyObject* type_SmartCardCryptogramStorageKeyAlgorithm;
        PyObject* type_SmartCardCryptogramStorageKeyCapabilities;
        PyObject* type_SmartCardCryptographicKeyAttestationStatus;
        PyObject* type_SmartCardEmulationCategory;
        PyObject* type_SmartCardEmulationType;
        PyObject* type_SmartCardEmulatorConnectionDeactivatedReason;
        PyObject* type_SmartCardEmulatorConnectionSource;
        PyObject* type_SmartCardEmulatorEnablementPolicy;
        PyObject* type_SmartCardLaunchBehavior;
        PyObject* type_SmartCardPinCharacterPolicyOption;
        PyObject* type_SmartCardReaderKind;
        PyObject* type_SmartCardReaderStatus;
        PyObject* type_SmartCardStatus;
        PyObject* type_SmartCardTriggerType;
        PyObject* type_SmartCardUnlockPromptingBehavior;
        PyTypeObject* type_CardAddedEventArgs;
        PyTypeObject* type_CardRemovedEventArgs;
        PyTypeObject* type_KnownSmartCardAppletIds;
        PyTypeObject* type_SmartCard;
        PyTypeObject* type_SmartCardAppletIdGroup;
        PyTypeObject* type_SmartCardAppletIdGroupRegistration;
        PyTypeObject* type_SmartCardAutomaticResponseApdu;
        PyTypeObject* type_SmartCardChallengeContext;
        PyTypeObject* type_SmartCardConnection;
        PyTypeObject* type_SmartCardCryptogramGenerator;
        PyTypeObject* type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult;
        PyTypeObject* type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult;
        PyTypeObject* type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult;
        PyTypeObject* type_SmartCardCryptogramMaterialCharacteristics;
        PyTypeObject* type_SmartCardCryptogramMaterialPackageCharacteristics;
        PyTypeObject* type_SmartCardCryptogramMaterialPossessionProof;
        PyTypeObject* type_SmartCardCryptogramPlacementStep;
        PyTypeObject* type_SmartCardCryptogramStorageKeyCharacteristics;
        PyTypeObject* type_SmartCardCryptogramStorageKeyInfo;
        PyTypeObject* type_SmartCardEmulator;
        PyTypeObject* type_SmartCardEmulatorApduReceivedEventArgs;
        PyTypeObject* type_SmartCardEmulatorConnectionDeactivatedEventArgs;
        PyTypeObject* type_SmartCardEmulatorConnectionProperties;
        PyTypeObject* type_SmartCardPinPolicy;
        PyTypeObject* type_SmartCardPinResetDeferral;
        PyTypeObject* type_SmartCardPinResetRequest;
        PyTypeObject* type_SmartCardProvisioning;
        PyTypeObject* type_SmartCardReader;
        PyTypeObject* type_SmartCardTriggerDetails;
    };

    static PyObject* register_SmartCardActivationPolicyChangeResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardActivationPolicyChangeResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardActivationPolicyChangeResult = type;
        Py_INCREF(state->type_SmartCardActivationPolicyChangeResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardAppletIdGroupActivationPolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardAppletIdGroupActivationPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardAppletIdGroupActivationPolicy = type;
        Py_INCREF(state->type_SmartCardAppletIdGroupActivationPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardAutomaticResponseStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardAutomaticResponseStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardAutomaticResponseStatus = type;
        Py_INCREF(state->type_SmartCardAutomaticResponseStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramAlgorithm(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramAlgorithm)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramAlgorithm = type;
        Py_INCREF(state->type_SmartCardCryptogramAlgorithm);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramGeneratorOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramGeneratorOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramGeneratorOperationStatus = type;
        Py_INCREF(state->type_SmartCardCryptogramGeneratorOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramMaterialPackageConfirmationResponseFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat = type;
        Py_INCREF(state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramMaterialPackageFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramMaterialPackageFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramMaterialPackageFormat = type;
        Py_INCREF(state->type_SmartCardCryptogramMaterialPackageFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramMaterialProtectionMethod(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramMaterialProtectionMethod)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramMaterialProtectionMethod = type;
        Py_INCREF(state->type_SmartCardCryptogramMaterialProtectionMethod);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramMaterialType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramMaterialType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramMaterialType = type;
        Py_INCREF(state->type_SmartCardCryptogramMaterialType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramPlacementOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramPlacementOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramPlacementOptions = type;
        Py_INCREF(state->type_SmartCardCryptogramPlacementOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramStorageKeyAlgorithm(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramStorageKeyAlgorithm)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramStorageKeyAlgorithm = type;
        Py_INCREF(state->type_SmartCardCryptogramStorageKeyAlgorithm);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptogramStorageKeyCapabilities(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptogramStorageKeyCapabilities)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptogramStorageKeyCapabilities = type;
        Py_INCREF(state->type_SmartCardCryptogramStorageKeyCapabilities);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardCryptographicKeyAttestationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardCryptographicKeyAttestationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardCryptographicKeyAttestationStatus = type;
        Py_INCREF(state->type_SmartCardCryptographicKeyAttestationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardEmulationCategory(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardEmulationCategory)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardEmulationCategory = type;
        Py_INCREF(state->type_SmartCardEmulationCategory);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardEmulationType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardEmulationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardEmulationType = type;
        Py_INCREF(state->type_SmartCardEmulationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardEmulatorConnectionDeactivatedReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardEmulatorConnectionDeactivatedReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardEmulatorConnectionDeactivatedReason = type;
        Py_INCREF(state->type_SmartCardEmulatorConnectionDeactivatedReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardEmulatorConnectionSource(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardEmulatorConnectionSource)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardEmulatorConnectionSource = type;
        Py_INCREF(state->type_SmartCardEmulatorConnectionSource);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardEmulatorEnablementPolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardEmulatorEnablementPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardEmulatorEnablementPolicy = type;
        Py_INCREF(state->type_SmartCardEmulatorEnablementPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardLaunchBehavior(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardLaunchBehavior)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardLaunchBehavior = type;
        Py_INCREF(state->type_SmartCardLaunchBehavior);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardPinCharacterPolicyOption(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardPinCharacterPolicyOption)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardPinCharacterPolicyOption = type;
        Py_INCREF(state->type_SmartCardPinCharacterPolicyOption);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardReaderKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardReaderKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardReaderKind = type;
        Py_INCREF(state->type_SmartCardReaderKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardReaderStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardReaderStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardReaderStatus = type;
        Py_INCREF(state->type_SmartCardReaderStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardStatus = type;
        Py_INCREF(state->type_SmartCardStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardTriggerType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardTriggerType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardTriggerType = type;
        Py_INCREF(state->type_SmartCardTriggerType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SmartCardUnlockPromptingBehavior(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SmartCardUnlockPromptingBehavior)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SmartCardUnlockPromptingBehavior = type;
        Py_INCREF(state->type_SmartCardUnlockPromptingBehavior);


        Py_RETURN_NONE;
    }

    // ----- CardAddedEventArgs class --------------------
    static constexpr const char* const type_name_CardAddedEventArgs = "CardAddedEventArgs";

    static PyObject* _new_CardAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CardAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_CardAddedEventArgs(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CardAddedEventArgs_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.CardAddedEventArgs", L"SmartCard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CardAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CardAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CardAddedEventArgs[] = {
        { "_assign_array_", _assign_array_CardAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CardAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CardAddedEventArgs[] = {
        { "smart_card", reinterpret_cast<getter>(CardAddedEventArgs_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CardAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CardAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CardAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CardAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CardAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CardAddedEventArgs =
    {
        "_winsdk_Windows_Devices_SmartCards.CardAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CardAddedEventArgs
    };

    // ----- CardRemovedEventArgs class --------------------
    static constexpr const char* const type_name_CardRemovedEventArgs = "CardRemovedEventArgs";

    static PyObject* _new_CardRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CardRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_CardRemovedEventArgs(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CardRemovedEventArgs_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.CardRemovedEventArgs", L"SmartCard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CardRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CardRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CardRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_CardRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CardRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CardRemovedEventArgs[] = {
        { "smart_card", reinterpret_cast<getter>(CardRemovedEventArgs_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CardRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CardRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CardRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CardRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CardRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CardRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_SmartCards.CardRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CardRemovedEventArgs
    };

    // ----- KnownSmartCardAppletIds class --------------------
    static constexpr const char* const type_name_KnownSmartCardAppletIds = "KnownSmartCardAppletIds";

    static PyObject* _new_KnownSmartCardAppletIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownSmartCardAppletIds);
        return nullptr;
    }

    static PyObject* KnownSmartCardAppletIds_get_PaymentSystemEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.KnownSmartCardAppletIds", L"PaymentSystemEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds::PaymentSystemEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSmartCardAppletIds_get_ProximityPaymentSystemEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.KnownSmartCardAppletIds", L"ProximityPaymentSystemEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds::ProximityPaymentSystemEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownSmartCardAppletIds[] = {
        { }
    };

    static PyGetSetDef _getset_KnownSmartCardAppletIds[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownSmartCardAppletIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownSmartCardAppletIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownSmartCardAppletIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownSmartCardAppletIds) },
        { },
    };

    static PyType_Spec type_spec_KnownSmartCardAppletIds =
    {
        "_winsdk_Windows_Devices_SmartCards.KnownSmartCardAppletIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownSmartCardAppletIds
    };

    static PyGetSetDef getset_KnownSmartCardAppletIds_Meta[] = {
        { "payment_system_environment", reinterpret_cast<getter>(KnownSmartCardAppletIds_get_PaymentSystemEnvironment), nullptr, nullptr, nullptr },
        { "proximity_payment_system_environment", reinterpret_cast<getter>(KnownSmartCardAppletIds_get_ProximityPaymentSystemEnvironment), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownSmartCardAppletIds_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownSmartCardAppletIds_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownSmartCardAppletIds_Meta =
    {
        "_winsdk_Windows_Devices_SmartCards.KnownSmartCardAppletIds_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownSmartCardAppletIds_Meta
    };

    // ----- SmartCard class --------------------
    static constexpr const char* const type_name_SmartCard = "SmartCard";

    static PyObject* _new_SmartCard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCard);
        return nullptr;
    }

    static void _dealloc_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCard* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCard_ConnectAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"ConnectAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_GetAnswerToResetAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"GetAnswerToResetAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAnswerToResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_GetStatusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"GetStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_get_Reader(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCard", L"Reader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCard[] = {
        { "connect_async", reinterpret_cast<PyCFunction>(SmartCard_ConnectAsync), METH_VARARGS, nullptr },
        { "get_answer_to_reset_async", reinterpret_cast<PyCFunction>(SmartCard_GetAnswerToResetAsync), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(SmartCard_GetStatusAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCard[] = {
        { "reader", reinterpret_cast<getter>(SmartCard_get_Reader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCard) },
        { },
    };

    static PyType_Spec type_spec_SmartCard =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCard",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCard
    };

    // ----- SmartCardAppletIdGroup class --------------------
    static constexpr const char* const type_name_SmartCardAppletIdGroup = "SmartCardAppletIdGroup";

    static PyObject* _new_SmartCardAppletIdGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IBuffer>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationType>(args, 3);

                winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardAppletIdGroup(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAppletIdGroup_get_SmartCardEmulationType(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCardEmulationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SmartCardEmulationType(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationType>(arg);

            self->obj.SmartCardEmulationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_SmartCardEmulationCategory(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCardEmulationCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SmartCardEmulationCategory(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory>(arg);

            self->obj.SmartCardEmulationCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_DisplayName(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_DisplayName(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_AutomaticEnablement(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AutomaticEnablement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomaticEnablement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_AutomaticEnablement(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AutomaticEnablement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutomaticEnablement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_AppletIds(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AppletIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppletIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_SecureUserAuthenticationRequired(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SecureUserAuthenticationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SecureUserAuthenticationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SecureUserAuthenticationRequired(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SecureUserAuthenticationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SecureUserAuthenticationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Logo(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_Logo(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Description(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_Description(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Properties(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_MaxAppletIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"MaxAppletIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup::MaxAppletIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardAppletIdGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAppletIdGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAppletIdGroup[] = {
        { "_assign_array_", _assign_array_SmartCardAppletIdGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAppletIdGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAppletIdGroup[] = {
        { "smart_card_emulation_type", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SmartCardEmulationType), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SmartCardEmulationType), nullptr, nullptr },
        { "smart_card_emulation_category", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SmartCardEmulationCategory), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SmartCardEmulationCategory), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_DisplayName), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_DisplayName), nullptr, nullptr },
        { "automatic_enablement", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_AutomaticEnablement), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_AutomaticEnablement), nullptr, nullptr },
        { "applet_ids", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_AppletIds), nullptr, nullptr, nullptr },
        { "secure_user_authentication_required", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SecureUserAuthenticationRequired), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SecureUserAuthenticationRequired), nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Logo), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_Logo), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Description), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_Description), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAppletIdGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAppletIdGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAppletIdGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAppletIdGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAppletIdGroup) },
        { },
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroup =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardAppletIdGroup",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAppletIdGroup
    };

    static PyGetSetDef getset_SmartCardAppletIdGroup_Meta[] = {
        { "max_applet_ids", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_MaxAppletIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardAppletIdGroup_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardAppletIdGroup_Meta) },
        { }
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroup_Meta =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardAppletIdGroup_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardAppletIdGroup_Meta
    };

    // ----- SmartCardAppletIdGroupRegistration class --------------------
    static constexpr const char* const type_name_SmartCardAppletIdGroupRegistration = "SmartCardAppletIdGroupRegistration";

    static PyObject* _new_SmartCardAppletIdGroupRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardAppletIdGroupRegistration);
        return nullptr;
    }

    static void _dealloc_SmartCardAppletIdGroupRegistration(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAppletIdGroupRegistration_RequestActivationPolicyChangeAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"RequestActivationPolicyChangeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupActivationPolicy>(args, 0);

                return py::convert(self->obj.RequestActivationPolicyChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_SetAutomaticResponseApdusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SetAutomaticResponseApdusAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>>(args, 0);

                return py::convert(self->obj.SetAutomaticResponseApdusAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_SetPropertiesAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.SetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_ActivationPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"ActivationPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_AppletIdGroup(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"AppletIdGroup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppletIdGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_Id(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_SmartCardReaderId(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SmartCardReaderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCardReaderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardAppletIdGroupRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAppletIdGroupRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAppletIdGroupRegistration[] = {
        { "request_activation_policy_change_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_RequestActivationPolicyChangeAsync), METH_VARARGS, nullptr },
        { "set_automatic_response_apdus_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_SetAutomaticResponseApdusAsync), METH_VARARGS, nullptr },
        { "set_properties_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_SetPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardAppletIdGroupRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAppletIdGroupRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAppletIdGroupRegistration[] = {
        { "activation_policy", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_ActivationPolicy), nullptr, nullptr, nullptr },
        { "applet_id_group", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_AppletIdGroup), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_Id), nullptr, nullptr, nullptr },
        { "smart_card_reader_id", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_SmartCardReaderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAppletIdGroupRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAppletIdGroupRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAppletIdGroupRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAppletIdGroupRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAppletIdGroupRegistration) },
        { },
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroupRegistration =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardAppletIdGroupRegistration",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAppletIdGroupRegistration
    };

    // ----- SmartCardAutomaticResponseApdu class --------------------
    static constexpr const char* const type_name_SmartCardAutomaticResponseApdu = "SmartCardAutomaticResponseApdu";

    static PyObject* _new_SmartCardAutomaticResponseApdu(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardAutomaticResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_ShouldMatchLength(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ShouldMatchLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldMatchLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_ShouldMatchLength(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ShouldMatchLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldMatchLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_ResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ResponseApdu"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_ResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ResponseApdu"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.ResponseApdu(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_CommandApduBitMask(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApduBitMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandApduBitMask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_CommandApduBitMask(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApduBitMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.CommandApduBitMask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApdu"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApdu"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.CommandApdu(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_AppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AppletId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppletId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_AppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AppletId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.AppletId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_OutputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"OutputState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_OutputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"OutputState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.OutputState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_InputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"InputState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_InputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"InputState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.InputState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_AllowWhenCryptogramGeneratorNotPrepared(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AllowWhenCryptogramGeneratorNotPrepared"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowWhenCryptogramGeneratorNotPrepared());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_AllowWhenCryptogramGeneratorNotPrepared(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AllowWhenCryptogramGeneratorNotPrepared"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWhenCryptogramGeneratorNotPrepared(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardAutomaticResponseApdu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAutomaticResponseApdu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAutomaticResponseApdu[] = {
        { "_assign_array_", _assign_array_SmartCardAutomaticResponseApdu, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAutomaticResponseApdu), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAutomaticResponseApdu[] = {
        { "should_match_length", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_ShouldMatchLength), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_ShouldMatchLength), nullptr, nullptr },
        { "response_apdu", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_ResponseApdu), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_ResponseApdu), nullptr, nullptr },
        { "command_apdu_bit_mask", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_CommandApduBitMask), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_CommandApduBitMask), nullptr, nullptr },
        { "command_apdu", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_CommandApdu), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_CommandApdu), nullptr, nullptr },
        { "applet_id", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_AppletId), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_AppletId), nullptr, nullptr },
        { "output_state", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_OutputState), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_OutputState), nullptr, nullptr },
        { "input_state", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_InputState), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_InputState), nullptr, nullptr },
        { "allow_when_cryptogram_generator_not_prepared", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_AllowWhenCryptogramGeneratorNotPrepared), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_AllowWhenCryptogramGeneratorNotPrepared), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAutomaticResponseApdu[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAutomaticResponseApdu) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAutomaticResponseApdu) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAutomaticResponseApdu) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAutomaticResponseApdu) },
        { },
    };

    static PyType_Spec type_spec_SmartCardAutomaticResponseApdu =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardAutomaticResponseApdu",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAutomaticResponseApdu
    };

    // ----- SmartCardChallengeContext class --------------------
    static constexpr const char* const type_name_SmartCardChallengeContext = "SmartCardChallengeContext";

    static PyObject* _new_SmartCardChallengeContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardChallengeContext);
        return nullptr;
    }

    static void _dealloc_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardChallengeContext_ChangeAdministrativeKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ChangeAdministrativeKeyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.ChangeAdministrativeKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_Close(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_ProvisionAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ProvisionAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.ProvisionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ProvisionAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ProvisionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_VerifyResponseAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"VerifyResponseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.VerifyResponseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_get_Challenge(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"Challenge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Challenge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardChallengeContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardChallengeContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardChallengeContext[] = {
        { "change_administrative_key_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_ChangeAdministrativeKeyAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_Close), METH_VARARGS, nullptr },
        { "provision_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_ProvisionAsync), METH_VARARGS, nullptr },
        { "verify_response_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_VerifyResponseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardChallengeContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardChallengeContext), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SmartCardChallengeContext), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SmartCardChallengeContext), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardChallengeContext[] = {
        { "challenge", reinterpret_cast<getter>(SmartCardChallengeContext_get_Challenge), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardChallengeContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardChallengeContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardChallengeContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardChallengeContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardChallengeContext) },
        { },
    };

    static PyType_Spec type_spec_SmartCardChallengeContext =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardChallengeContext",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardChallengeContext
    };

    // ----- SmartCardConnection class --------------------
    static constexpr const char* const type_name_SmartCardConnection = "SmartCardConnection";

    static PyObject* _new_SmartCardConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardConnection);
        return nullptr;
    }

    static void _dealloc_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardConnection_Close(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardConnection", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardConnection_TransmitAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardConnection", L"TransmitAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.TransmitAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(SmartCardConnection_Close), METH_VARARGS, nullptr },
        { "transmit_async", reinterpret_cast<PyCFunction>(SmartCardConnection_TransmitAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SmartCardConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SmartCardConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartCardConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardConnection) },
        { },
    };

    static PyType_Spec type_spec_SmartCardConnection =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardConnection",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardConnection
    };

    // ----- SmartCardCryptogramGenerator class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramGenerator = "SmartCardCryptogramGenerator";

    static PyObject* _new_SmartCardCryptogramGenerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardCryptogramGenerator);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramGenerator(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGenerator_CreateCryptogramMaterialStorageKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"CreateCryptogramMaterialStorageKeyAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyAlgorithm>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCapabilities>(args, 3);

                return py::convert(self->obj.CreateCryptogramMaterialStorageKeyAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_DeleteCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"DeleteCryptogramMaterialPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteCryptogramMaterialPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_DeleteCryptogramMaterialStorageKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"DeleteCryptogramMaterialStorageKeyAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteCryptogramMaterialStorageKeyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramMaterialCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialCharacteristicsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetAllCryptogramMaterialCharacteristicsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramMaterialPackageCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialPackageCharacteristicsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllCryptogramMaterialPackageCharacteristicsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialPackageCharacteristicsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAllCryptogramMaterialPackageCharacteristicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramStorageKeyCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramStorageKeyCharacteristicsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllCryptogramStorageKeyCharacteristicsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetSmartCardCryptogramGeneratorAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetSmartCardCryptogramGeneratorAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator::GetSmartCardCryptogramGeneratorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_ImportCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"ImportCryptogramMaterialPackageAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageFormat>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(self->obj.ImportCryptogramMaterialPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_RequestCryptogramMaterialStorageKeyInfoAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"RequestCryptogramMaterialStorageKeyInfoAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 2);

                return py::convert(self->obj.RequestCryptogramMaterialStorageKeyInfoAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_RequestUnlockCryptogramMaterialForUseAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"RequestUnlockCryptogramMaterialForUseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);

                return py::convert(self->obj.RequestUnlockCryptogramMaterialForUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_TryProvePossessionOfCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"TryProvePossessionOfCryptogramMaterialPackageAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageConfirmationResponseFormat>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(self->obj.TryProvePossessionOfCryptogramMaterialPackageAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_ValidateRequestApduAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"ValidateRequestApduAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 2);

                return py::convert(self->obj.ValidateRequestApduAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramAlgorithms"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCryptogramAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageConfirmationResponseFormats(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialPackageConfirmationResponseFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCryptogramMaterialPackageConfirmationResponseFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageFormats(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialPackageFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCryptogramMaterialPackageFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialTypes(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCryptogramMaterialTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedSmartCardCryptogramStorageKeyCapabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedSmartCardCryptogramStorageKeyCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedSmartCardCryptogramStorageKeyCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGenerator[] = {
        { "create_cryptogram_material_storage_key_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_CreateCryptogramMaterialStorageKeyAsync), METH_VARARGS, nullptr },
        { "delete_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_DeleteCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "delete_cryptogram_material_storage_key_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_DeleteCryptogramMaterialStorageKeyAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_material_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramMaterialCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_material_package_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramMaterialPackageCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_storage_key_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramStorageKeyCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_smart_card_cryptogram_generator_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetSmartCardCryptogramGeneratorAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "import_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_ImportCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "request_cryptogram_material_storage_key_info_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_RequestCryptogramMaterialStorageKeyInfoAsync), METH_VARARGS, nullptr },
        { "request_unlock_cryptogram_material_for_use_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_RequestUnlockCryptogramMaterialForUseAsync), METH_VARARGS, nullptr },
        { "try_prove_possession_of_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_TryProvePossessionOfCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "validate_request_apdu_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_ValidateRequestApduAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardCryptogramGenerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGenerator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGenerator[] = {
        { "supported_cryptogram_algorithms", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramAlgorithms), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_package_confirmation_response_formats", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageConfirmationResponseFormats), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_package_formats", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageFormats), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_types", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialTypes), nullptr, nullptr, nullptr },
        { "supported_smart_card_cryptogram_storage_key_capabilities", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedSmartCardCryptogramStorageKeyCapabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGenerator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGenerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGenerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGenerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGenerator) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramGenerator =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramGenerator",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGenerator
    };

    // ----- SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult = "SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult";

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult", L"Characteristics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult
    };

    // ----- SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult = "SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult";

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult", L"Characteristics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult
    };

    // ----- SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult = "SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult";

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult", L"Characteristics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult
    };

    // ----- SmartCardCryptogramMaterialCharacteristics class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramMaterialCharacteristics = "SmartCardCryptogramMaterialCharacteristics";

    static PyObject* _new_SmartCardCryptogramMaterialCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramMaterialCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedAlgorithms"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedProofOfPossessionAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedProofOfPossessionAlgorithms"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedProofOfPossessionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedValidations(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedValidations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedValidations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaterialLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaterialName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialType(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaterialType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_ProtectionMethod(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"ProtectionMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_ProtectionVersion(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"ProtectionVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialCharacteristics[] = {
        { "allowed_algorithms", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedAlgorithms), nullptr, nullptr, nullptr },
        { "allowed_proof_of_possession_algorithms", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedProofOfPossessionAlgorithms), nullptr, nullptr, nullptr },
        { "allowed_validations", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedValidations), nullptr, nullptr, nullptr },
        { "material_length", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialLength), nullptr, nullptr, nullptr },
        { "material_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialName), nullptr, nullptr, nullptr },
        { "material_type", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialType), nullptr, nullptr, nullptr },
        { "protection_method", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_ProtectionMethod), nullptr, nullptr, nullptr },
        { "protection_version", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_ProtectionVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialCharacteristics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialCharacteristics) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialCharacteristics =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramMaterialCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialCharacteristics
    };

    // ----- SmartCardCryptogramMaterialPackageCharacteristics class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramMaterialPackageCharacteristics = "SmartCardCryptogramMaterialPackageCharacteristics";

    static PyObject* _new_SmartCardCryptogramMaterialPackageCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramMaterialPackageCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_DateImported(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"DateImported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DateImported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_PackageFormat(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"PackageFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_PackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"PackageName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_StorageKeyName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"StorageKeyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorageKeyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialPackageCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialPackageCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialPackageCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialPackageCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialPackageCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialPackageCharacteristics[] = {
        { "date_imported", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_DateImported), nullptr, nullptr, nullptr },
        { "package_format", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_PackageFormat), nullptr, nullptr, nullptr },
        { "package_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_PackageName), nullptr, nullptr, nullptr },
        { "storage_key_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_StorageKeyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialPackageCharacteristics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialPackageCharacteristics) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialPackageCharacteristics =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramMaterialPackageCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialPackageCharacteristics
    };

    // ----- SmartCardCryptogramMaterialPossessionProof class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramMaterialPossessionProof = "SmartCardCryptogramMaterialPossessionProof";

    static PyObject* _new_SmartCardCryptogramMaterialPossessionProof(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardCryptogramMaterialPossessionProof);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramMaterialPossessionProof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialPossessionProof_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPossessionProof", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPossessionProof_get_Proof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPossessionProof", L"Proof"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Proof());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialPossessionProof(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialPossessionProof(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialPossessionProof[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialPossessionProof, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialPossessionProof), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialPossessionProof[] = {
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramMaterialPossessionProof_get_OperationStatus), nullptr, nullptr, nullptr },
        { "proof", reinterpret_cast<getter>(SmartCardCryptogramMaterialPossessionProof_get_Proof), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialPossessionProof[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialPossessionProof) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialPossessionProof =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramMaterialPossessionProof",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialPossessionProof
    };

    // ----- SmartCardCryptogramPlacementStep class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramPlacementStep = "SmartCardCryptogramPlacementStep";

    static PyObject* _new_SmartCardCryptogramPlacementStep(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramPlacementStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_TemplateOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"TemplateOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TemplateOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_TemplateOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"TemplateOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TemplateOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_SourceData(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"SourceData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_SourceData(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"SourceData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.SourceData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramPlacementOptions(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramPlacementOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CryptogramPlacementOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramPlacementOptions(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramPlacementOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementOptions>(arg);

            self->obj.CryptogramPlacementOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CryptogramOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CryptogramOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramMaterialPackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialPackageName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CryptogramMaterialPackageName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramMaterialPackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialPackageName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CryptogramMaterialPackageName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramMaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CryptogramMaterialName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramMaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CryptogramMaterialName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CryptogramLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CryptogramLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_ChainedOutputStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"ChainedOutputStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChainedOutputStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_ChainedOutputStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"ChainedOutputStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>(arg);

            self->obj.ChainedOutputStep(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"Algorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Algorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"Algorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramAlgorithm>(arg);

            self->obj.Algorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramPlacementStep(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramPlacementStep(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramPlacementStep[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramPlacementStep, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramPlacementStep), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramPlacementStep[] = {
        { "template_offset", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_TemplateOffset), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_TemplateOffset), nullptr, nullptr },
        { "source_data", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_SourceData), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_SourceData), nullptr, nullptr },
        { "cryptogram_placement_options", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramPlacementOptions), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramPlacementOptions), nullptr, nullptr },
        { "cryptogram_offset", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramOffset), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramOffset), nullptr, nullptr },
        { "cryptogram_material_package_name", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramMaterialPackageName), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramMaterialPackageName), nullptr, nullptr },
        { "cryptogram_material_name", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramMaterialName), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramMaterialName), nullptr, nullptr },
        { "cryptogram_length", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramLength), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramLength), nullptr, nullptr },
        { "chained_output_step", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_ChainedOutputStep), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_ChainedOutputStep), nullptr, nullptr },
        { "algorithm", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_Algorithm), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_Algorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramPlacementStep[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramPlacementStep) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramPlacementStep) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramPlacementStep) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramPlacementStep) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramPlacementStep =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramPlacementStep",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramPlacementStep
    };

    // ----- SmartCardCryptogramStorageKeyCharacteristics class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramStorageKeyCharacteristics = "SmartCardCryptogramStorageKeyCharacteristics";

    static PyObject* _new_SmartCardCryptogramStorageKeyCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramStorageKeyCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"Algorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Algorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_Capabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_DateCreated(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"DateCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_StorageKeyName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"StorageKeyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorageKeyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramStorageKeyCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramStorageKeyCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramStorageKeyCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramStorageKeyCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramStorageKeyCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramStorageKeyCharacteristics[] = {
        { "algorithm", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_Algorithm), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_Capabilities), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_DateCreated), nullptr, nullptr, nullptr },
        { "storage_key_name", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_StorageKeyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramStorageKeyCharacteristics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramStorageKeyCharacteristics) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramStorageKeyCharacteristics =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramStorageKeyCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramStorageKeyCharacteristics
    };

    // ----- SmartCardCryptogramStorageKeyInfo class --------------------
    static constexpr const char* const type_name_SmartCardCryptogramStorageKeyInfo = "SmartCardCryptogramStorageKeyInfo";

    static PyObject* _new_SmartCardCryptogramStorageKeyInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardCryptogramStorageKeyInfo);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramStorageKeyInfo(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_Attestation(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"Attestation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Attestation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_AttestationCertificateChain(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"AttestationCertificateChain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttestationCertificateChain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_AttestationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"AttestationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttestationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_Capabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_PublicKey(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"PublicKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PublicKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_PublicKeyBlobType(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"PublicKeyBlobType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PublicKeyBlobType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_OperationalRequirements(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"OperationalRequirements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationalRequirements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramStorageKeyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramStorageKeyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramStorageKeyInfo[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramStorageKeyInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramStorageKeyInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramStorageKeyInfo[] = {
        { "attestation", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_Attestation), nullptr, nullptr, nullptr },
        { "attestation_certificate_chain", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_AttestationCertificateChain), nullptr, nullptr, nullptr },
        { "attestation_status", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_AttestationStatus), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_Capabilities), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_OperationStatus), nullptr, nullptr, nullptr },
        { "public_key", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_PublicKey), nullptr, nullptr, nullptr },
        { "public_key_blob_type", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_PublicKeyBlobType), nullptr, nullptr, nullptr },
        { "operational_requirements", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_OperationalRequirements), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramStorageKeyInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramStorageKeyInfo) },
        { },
    };

    static PyType_Spec type_spec_SmartCardCryptogramStorageKeyInfo =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardCryptogramStorageKeyInfo",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramStorageKeyInfo
    };

    // ----- SmartCardEmulator class --------------------
    static constexpr const char* const type_name_SmartCardEmulator = "SmartCardEmulator";

    static PyObject* _new_SmartCardEmulator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardEmulator);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulator(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulator_GetAppletIdGroupRegistrationsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"GetAppletIdGroupRegistrationsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::GetAppletIdGroupRegistrationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_IsHostCardEmulationSupported(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"IsHostCardEmulationSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsHostCardEmulationSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_RegisterAppletIdGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"RegisterAppletIdGroupAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::RegisterAppletIdGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_Start(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_UnregisterAppletIdGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"UnregisterAppletIdGroupAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::UnregisterAppletIdGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_get_EnablementPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"EnablementPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnablementPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_get_MaxAppletIdGroupRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"MaxAppletIdGroupRegistrations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::MaxAppletIdGroupRegistrations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_add_ApduReceived(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ApduReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardEmulator, winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>>(arg);

            return py::convert(self->obj.ApduReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_remove_ApduReceived(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ApduReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ApduReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_add_ConnectionDeactivated(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ConnectionDeactivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardEmulator, winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionDeactivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_remove_ConnectionDeactivated(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ConnectionDeactivated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionDeactivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulator[] = {
        { "get_applet_id_group_registrations_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_GetAppletIdGroupRegistrationsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_host_card_emulation_supported", reinterpret_cast<PyCFunction>(SmartCardEmulator_IsHostCardEmulationSupported), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(SmartCardEmulator_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "register_applet_id_group_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_RegisterAppletIdGroupAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "start", reinterpret_cast<PyCFunction>(SmartCardEmulator_Start), METH_VARARGS, nullptr },
        { "unregister_applet_id_group_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_UnregisterAppletIdGroupAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_apdu_received", reinterpret_cast<PyCFunction>(SmartCardEmulator_add_ApduReceived), METH_O, nullptr },
        { "remove_apdu_received", reinterpret_cast<PyCFunction>(SmartCardEmulator_remove_ApduReceived), METH_O, nullptr },
        { "add_connection_deactivated", reinterpret_cast<PyCFunction>(SmartCardEmulator_add_ConnectionDeactivated), METH_O, nullptr },
        { "remove_connection_deactivated", reinterpret_cast<PyCFunction>(SmartCardEmulator_remove_ConnectionDeactivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmartCardEmulator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulator[] = {
        { "enablement_policy", reinterpret_cast<getter>(SmartCardEmulator_get_EnablementPolicy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulator) },
        { },
    };

    static PyType_Spec type_spec_SmartCardEmulator =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardEmulator",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulator
    };

    static PyGetSetDef getset_SmartCardEmulator_Meta[] = {
        { "max_applet_id_group_registrations", reinterpret_cast<getter>(SmartCardEmulator_get_MaxAppletIdGroupRegistrations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardEmulator_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardEmulator_Meta) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulator_Meta =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardEmulator_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardEmulator_Meta
    };

    // ----- SmartCardEmulatorApduReceivedEventArgs class --------------------
    static constexpr const char* const type_name_SmartCardEmulatorApduReceivedEventArgs = "SmartCardEmulatorApduReceivedEventArgs";

    static PyObject* _new_SmartCardEmulatorApduReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardEmulatorApduReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorApduReceivedEventArgs(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_TryRespondAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.TryRespondAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.TryRespondAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_TryRespondWithCryptogramsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondWithCryptogramsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 1);

                return py::convert(self->obj.TryRespondWithCryptogramsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondWithCryptogramsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 2);

                return py::convert(self->obj.TryRespondWithCryptogramsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_AutomaticResponseStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"AutomaticResponseStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomaticResponseStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"CommandApdu"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_ConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"ConnectionProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_State(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorApduReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorApduReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorApduReceivedEventArgs[] = {
        { "try_respond_async", reinterpret_cast<PyCFunction>(SmartCardEmulatorApduReceivedEventArgs_TryRespondAsync), METH_VARARGS, nullptr },
        { "try_respond_with_cryptograms_async", reinterpret_cast<PyCFunction>(SmartCardEmulatorApduReceivedEventArgs_TryRespondWithCryptogramsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardEmulatorApduReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorApduReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorApduReceivedEventArgs[] = {
        { "automatic_response_status", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_AutomaticResponseStatus), nullptr, nullptr, nullptr },
        { "command_apdu", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_CommandApdu), nullptr, nullptr, nullptr },
        { "connection_properties", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_ConnectionProperties), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorApduReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorApduReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SmartCardEmulatorApduReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardEmulatorApduReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorApduReceivedEventArgs
    };

    // ----- SmartCardEmulatorConnectionDeactivatedEventArgs class --------------------
    static constexpr const char* const type_name_SmartCardEmulatorConnectionDeactivatedEventArgs = "SmartCardEmulatorConnectionDeactivatedEventArgs";

    static PyObject* _new_SmartCardEmulatorConnectionDeactivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardEmulatorConnectionDeactivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorConnectionDeactivatedEventArgs(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorConnectionDeactivatedEventArgs_get_ConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionDeactivatedEventArgs", L"ConnectionProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorConnectionDeactivatedEventArgs_get_Reason(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionDeactivatedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorConnectionDeactivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorConnectionDeactivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorConnectionDeactivatedEventArgs[] = {
        { "_assign_array_", _assign_array_SmartCardEmulatorConnectionDeactivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorConnectionDeactivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorConnectionDeactivatedEventArgs[] = {
        { "connection_properties", reinterpret_cast<getter>(SmartCardEmulatorConnectionDeactivatedEventArgs_get_ConnectionProperties), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(SmartCardEmulatorConnectionDeactivatedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorConnectionDeactivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SmartCardEmulatorConnectionDeactivatedEventArgs =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardEmulatorConnectionDeactivatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorConnectionDeactivatedEventArgs
    };

    // ----- SmartCardEmulatorConnectionProperties class --------------------
    static constexpr const char* const type_name_SmartCardEmulatorConnectionProperties = "SmartCardEmulatorConnectionProperties";

    static PyObject* _new_SmartCardEmulatorConnectionProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardEmulatorConnectionProperties);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorConnectionProperties_get_Id(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionProperties", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorConnectionProperties_get_Source(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionProperties", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorConnectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorConnectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorConnectionProperties[] = {
        { "_assign_array_", _assign_array_SmartCardEmulatorConnectionProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorConnectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorConnectionProperties[] = {
        { "id", reinterpret_cast<getter>(SmartCardEmulatorConnectionProperties_get_Id), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SmartCardEmulatorConnectionProperties_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorConnectionProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorConnectionProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorConnectionProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorConnectionProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorConnectionProperties) },
        { },
    };

    static PyType_Spec type_spec_SmartCardEmulatorConnectionProperties =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardEmulatorConnectionProperties",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorConnectionProperties
    };

    // ----- SmartCardPinPolicy class --------------------
    static constexpr const char* const type_name_SmartCardPinPolicy = "SmartCardPinPolicy";

    static PyObject* _new_SmartCardPinPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardPinPolicy instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardPinPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinPolicy_get_UppercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"UppercaseLetters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UppercaseLetters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_UppercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"UppercaseLetters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.UppercaseLetters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_SpecialCharacters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"SpecialCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpecialCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_SpecialCharacters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"SpecialCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.SpecialCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_MinLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MinLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_MinLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MinLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MinLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_MaxLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MaxLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_MaxLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MaxLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_LowercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"LowercaseLetters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowercaseLetters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_LowercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"LowercaseLetters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.LowercaseLetters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_Digits(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"Digits"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Digits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_Digits(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"Digits"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.Digits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardPinPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinPolicy[] = {
        { "_assign_array_", _assign_array_SmartCardPinPolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinPolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinPolicy[] = {
        { "uppercase_letters", reinterpret_cast<getter>(SmartCardPinPolicy_get_UppercaseLetters), reinterpret_cast<setter>(SmartCardPinPolicy_put_UppercaseLetters), nullptr, nullptr },
        { "special_characters", reinterpret_cast<getter>(SmartCardPinPolicy_get_SpecialCharacters), reinterpret_cast<setter>(SmartCardPinPolicy_put_SpecialCharacters), nullptr, nullptr },
        { "min_length", reinterpret_cast<getter>(SmartCardPinPolicy_get_MinLength), reinterpret_cast<setter>(SmartCardPinPolicy_put_MinLength), nullptr, nullptr },
        { "max_length", reinterpret_cast<getter>(SmartCardPinPolicy_get_MaxLength), reinterpret_cast<setter>(SmartCardPinPolicy_put_MaxLength), nullptr, nullptr },
        { "lowercase_letters", reinterpret_cast<getter>(SmartCardPinPolicy_get_LowercaseLetters), reinterpret_cast<setter>(SmartCardPinPolicy_put_LowercaseLetters), nullptr, nullptr },
        { "digits", reinterpret_cast<getter>(SmartCardPinPolicy_get_Digits), reinterpret_cast<setter>(SmartCardPinPolicy_put_Digits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinPolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinPolicy) },
        { },
    };

    static PyType_Spec type_spec_SmartCardPinPolicy =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardPinPolicy",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinPolicy
    };

    // ----- SmartCardPinResetDeferral class --------------------
    static constexpr const char* const type_name_SmartCardPinResetDeferral = "SmartCardPinResetDeferral";

    static PyObject* _new_SmartCardPinResetDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardPinResetDeferral);
        return nullptr;
    }

    static void _dealloc_SmartCardPinResetDeferral(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinResetDeferral_Complete(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardPinResetDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinResetDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinResetDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SmartCardPinResetDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardPinResetDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinResetDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinResetDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinResetDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinResetDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinResetDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinResetDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinResetDeferral) },
        { },
    };

    static PyType_Spec type_spec_SmartCardPinResetDeferral =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardPinResetDeferral",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinResetDeferral
    };

    // ----- SmartCardPinResetRequest class --------------------
    static constexpr const char* const type_name_SmartCardPinResetRequest = "SmartCardPinResetRequest";

    static PyObject* _new_SmartCardPinResetRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardPinResetRequest);
        return nullptr;
    }

    static void _dealloc_SmartCardPinResetRequest(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinResetRequest_GetDeferral(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_SetResponse(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"SetResponse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SetResponse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_get_Challenge(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"Challenge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Challenge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_get_Deadline(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardPinResetRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinResetRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinResetRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SmartCardPinResetRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_response", reinterpret_cast<PyCFunction>(SmartCardPinResetRequest_SetResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardPinResetRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinResetRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinResetRequest[] = {
        { "challenge", reinterpret_cast<getter>(SmartCardPinResetRequest_get_Challenge), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(SmartCardPinResetRequest_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinResetRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinResetRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinResetRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinResetRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinResetRequest) },
        { },
    };

    static PyType_Spec type_spec_SmartCardPinResetRequest =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardPinResetRequest",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinResetRequest
    };

    // ----- SmartCardProvisioning class --------------------
    static constexpr const char* const type_name_SmartCardProvisioning = "SmartCardProvisioning";

    static PyObject* _new_SmartCardProvisioning(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardProvisioning);
        return nullptr;
    }

    static void _dealloc_SmartCardProvisioning(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardProvisioning_FromSmartCardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"FromSmartCardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCard>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::FromSmartCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetAuthorityKeyContainerNameAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetAuthorityKeyContainerNameAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAuthorityKeyContainerNameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetChallengeContextAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetChallengeContextAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChallengeContextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetIdAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetIdAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetNameAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetNameAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestAttestedVirtualSmartCardCreationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestAttestedVirtualSmartCardCreationAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestAttestedVirtualSmartCardCreationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestAttestedVirtualSmartCardCreationAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);
                auto param3 = py::convert_to<winrt::guid>(args, 3);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestAttestedVirtualSmartCardCreationAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestPinChangeAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestPinChangeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPinChangeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestPinResetAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestPinResetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinResetHandler>(args, 0);

                return py::convert(self->obj.RequestPinResetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestVirtualSmartCardCreationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardCreationAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardCreationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardCreationAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);
                auto param3 = py::convert_to<winrt::guid>(args, 3);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardCreationAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestVirtualSmartCardDeletionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardDeletionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCard>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardDeletionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"SmartCard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardProvisioning(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardProvisioning(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardProvisioning[] = {
        { "from_smart_card_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_FromSmartCardAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_authority_key_container_name_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetAuthorityKeyContainerNameAsync), METH_VARARGS, nullptr },
        { "get_challenge_context_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetChallengeContextAsync), METH_VARARGS, nullptr },
        { "get_id_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetIdAsync), METH_VARARGS, nullptr },
        { "get_name_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetNameAsync), METH_VARARGS, nullptr },
        { "request_attested_virtual_smart_card_creation_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestAttestedVirtualSmartCardCreationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_pin_change_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestPinChangeAsync), METH_VARARGS, nullptr },
        { "request_pin_reset_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestPinResetAsync), METH_VARARGS, nullptr },
        { "request_virtual_smart_card_creation_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestVirtualSmartCardCreationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_virtual_smart_card_deletion_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestVirtualSmartCardDeletionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_SmartCardProvisioning, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardProvisioning), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardProvisioning[] = {
        { "smart_card", reinterpret_cast<getter>(SmartCardProvisioning_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardProvisioning[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardProvisioning) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardProvisioning) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardProvisioning) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardProvisioning) },
        { },
    };

    static PyType_Spec type_spec_SmartCardProvisioning =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardProvisioning",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardProvisioning
    };

    // ----- SmartCardReader class --------------------
    static constexpr const char* const type_name_SmartCardReader = "SmartCardReader";

    static PyObject* _new_SmartCardReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardReader);
        return nullptr;
    }

    static void _dealloc_SmartCardReader(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardReader_FindAllCardsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"FindAllCardsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindAllCardsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardReaderKind>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_GetStatusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_DeviceId(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_Kind(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_Name(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_add_CardAdded(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardReader, winrt::Windows::Devices::SmartCards::CardAddedEventArgs>>(arg);

            return py::convert(self->obj.CardAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_remove_CardAdded(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CardAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_add_CardRemoved(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardReader, winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>>(arg);

            return py::convert(self->obj.CardRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_remove_CardRemoved(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CardRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardReader[] = {
        { "find_all_cards_async", reinterpret_cast<PyCFunction>(SmartCardReader_FindAllCardsAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(SmartCardReader_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmartCardReader_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(SmartCardReader_GetStatusAsync), METH_VARARGS, nullptr },
        { "add_card_added", reinterpret_cast<PyCFunction>(SmartCardReader_add_CardAdded), METH_O, nullptr },
        { "remove_card_added", reinterpret_cast<PyCFunction>(SmartCardReader_remove_CardAdded), METH_O, nullptr },
        { "add_card_removed", reinterpret_cast<PyCFunction>(SmartCardReader_add_CardRemoved), METH_O, nullptr },
        { "remove_card_removed", reinterpret_cast<PyCFunction>(SmartCardReader_remove_CardRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmartCardReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardReader[] = {
        { "device_id", reinterpret_cast<getter>(SmartCardReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SmartCardReader_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SmartCardReader_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardReader) },
        { },
    };

    static PyType_Spec type_spec_SmartCardReader =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardReader",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardReader
    };

    // ----- SmartCardTriggerDetails class --------------------
    static constexpr const char* const type_name_SmartCardTriggerDetails = "SmartCardTriggerDetails";

    static PyObject* _new_SmartCardTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartCardTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SmartCardTriggerDetails(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardTriggerDetails_TryLaunchCurrentAppAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TryLaunchCurrentAppAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryLaunchCurrentAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TryLaunchCurrentAppAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardLaunchBehavior>(args, 1);

                return py::convert(self->obj.TryLaunchCurrentAppAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_SourceAppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"SourceAppletId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceAppletId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_TriggerData(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TriggerData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_TriggerType(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TriggerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_Emulator(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"Emulator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emulator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"SmartCard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardTriggerDetails[] = {
        { "try_launch_current_app_async", reinterpret_cast<PyCFunction>(SmartCardTriggerDetails_TryLaunchCurrentAppAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardTriggerDetails[] = {
        { "source_applet_id", reinterpret_cast<getter>(SmartCardTriggerDetails_get_SourceAppletId), nullptr, nullptr, nullptr },
        { "trigger_data", reinterpret_cast<getter>(SmartCardTriggerDetails_get_TriggerData), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(SmartCardTriggerDetails_get_TriggerType), nullptr, nullptr, nullptr },
        { "emulator", reinterpret_cast<getter>(SmartCardTriggerDetails_get_Emulator), nullptr, nullptr, nullptr },
        { "smart_card", reinterpret_cast<getter>(SmartCardTriggerDetails_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_SmartCardTriggerDetails =
    {
        "_winsdk_Windows_Devices_SmartCards.SmartCardTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardTriggerDetails
    };

    // ----- Windows.Devices.SmartCards Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::SmartCards");

    static PyMethodDef module_methods[] = {
        {"_register_SmartCardActivationPolicyChangeResult", register_SmartCardActivationPolicyChangeResult, METH_O, "registers type"},
        {"_register_SmartCardAppletIdGroupActivationPolicy", register_SmartCardAppletIdGroupActivationPolicy, METH_O, "registers type"},
        {"_register_SmartCardAutomaticResponseStatus", register_SmartCardAutomaticResponseStatus, METH_O, "registers type"},
        {"_register_SmartCardCryptogramAlgorithm", register_SmartCardCryptogramAlgorithm, METH_O, "registers type"},
        {"_register_SmartCardCryptogramGeneratorOperationStatus", register_SmartCardCryptogramGeneratorOperationStatus, METH_O, "registers type"},
        {"_register_SmartCardCryptogramMaterialPackageConfirmationResponseFormat", register_SmartCardCryptogramMaterialPackageConfirmationResponseFormat, METH_O, "registers type"},
        {"_register_SmartCardCryptogramMaterialPackageFormat", register_SmartCardCryptogramMaterialPackageFormat, METH_O, "registers type"},
        {"_register_SmartCardCryptogramMaterialProtectionMethod", register_SmartCardCryptogramMaterialProtectionMethod, METH_O, "registers type"},
        {"_register_SmartCardCryptogramMaterialType", register_SmartCardCryptogramMaterialType, METH_O, "registers type"},
        {"_register_SmartCardCryptogramPlacementOptions", register_SmartCardCryptogramPlacementOptions, METH_O, "registers type"},
        {"_register_SmartCardCryptogramStorageKeyAlgorithm", register_SmartCardCryptogramStorageKeyAlgorithm, METH_O, "registers type"},
        {"_register_SmartCardCryptogramStorageKeyCapabilities", register_SmartCardCryptogramStorageKeyCapabilities, METH_O, "registers type"},
        {"_register_SmartCardCryptographicKeyAttestationStatus", register_SmartCardCryptographicKeyAttestationStatus, METH_O, "registers type"},
        {"_register_SmartCardEmulationCategory", register_SmartCardEmulationCategory, METH_O, "registers type"},
        {"_register_SmartCardEmulationType", register_SmartCardEmulationType, METH_O, "registers type"},
        {"_register_SmartCardEmulatorConnectionDeactivatedReason", register_SmartCardEmulatorConnectionDeactivatedReason, METH_O, "registers type"},
        {"_register_SmartCardEmulatorConnectionSource", register_SmartCardEmulatorConnectionSource, METH_O, "registers type"},
        {"_register_SmartCardEmulatorEnablementPolicy", register_SmartCardEmulatorEnablementPolicy, METH_O, "registers type"},
        {"_register_SmartCardLaunchBehavior", register_SmartCardLaunchBehavior, METH_O, "registers type"},
        {"_register_SmartCardPinCharacterPolicyOption", register_SmartCardPinCharacterPolicyOption, METH_O, "registers type"},
        {"_register_SmartCardReaderKind", register_SmartCardReaderKind, METH_O, "registers type"},
        {"_register_SmartCardReaderStatus", register_SmartCardReaderStatus, METH_O, "registers type"},
        {"_register_SmartCardStatus", register_SmartCardStatus, METH_O, "registers type"},
        {"_register_SmartCardTriggerType", register_SmartCardTriggerType, METH_O, "registers type"},
        {"_register_SmartCardUnlockPromptingBehavior", register_SmartCardUnlockPromptingBehavior, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_SmartCardActivationPolicyChangeResult);
        Py_VISIT(state->type_SmartCardAppletIdGroupActivationPolicy);
        Py_VISIT(state->type_SmartCardAutomaticResponseStatus);
        Py_VISIT(state->type_SmartCardCryptogramAlgorithm);
        Py_VISIT(state->type_SmartCardCryptogramGeneratorOperationStatus);
        Py_VISIT(state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat);
        Py_VISIT(state->type_SmartCardCryptogramMaterialPackageFormat);
        Py_VISIT(state->type_SmartCardCryptogramMaterialProtectionMethod);
        Py_VISIT(state->type_SmartCardCryptogramMaterialType);
        Py_VISIT(state->type_SmartCardCryptogramPlacementOptions);
        Py_VISIT(state->type_SmartCardCryptogramStorageKeyAlgorithm);
        Py_VISIT(state->type_SmartCardCryptogramStorageKeyCapabilities);
        Py_VISIT(state->type_SmartCardCryptographicKeyAttestationStatus);
        Py_VISIT(state->type_SmartCardEmulationCategory);
        Py_VISIT(state->type_SmartCardEmulationType);
        Py_VISIT(state->type_SmartCardEmulatorConnectionDeactivatedReason);
        Py_VISIT(state->type_SmartCardEmulatorConnectionSource);
        Py_VISIT(state->type_SmartCardEmulatorEnablementPolicy);
        Py_VISIT(state->type_SmartCardLaunchBehavior);
        Py_VISIT(state->type_SmartCardPinCharacterPolicyOption);
        Py_VISIT(state->type_SmartCardReaderKind);
        Py_VISIT(state->type_SmartCardReaderStatus);
        Py_VISIT(state->type_SmartCardStatus);
        Py_VISIT(state->type_SmartCardTriggerType);
        Py_VISIT(state->type_SmartCardUnlockPromptingBehavior);
        Py_VISIT(state->type_CardAddedEventArgs);
        Py_VISIT(state->type_CardRemovedEventArgs);
        Py_VISIT(state->type_KnownSmartCardAppletIds);
        Py_VISIT(state->type_SmartCard);
        Py_VISIT(state->type_SmartCardAppletIdGroup);
        Py_VISIT(state->type_SmartCardAppletIdGroupRegistration);
        Py_VISIT(state->type_SmartCardAutomaticResponseApdu);
        Py_VISIT(state->type_SmartCardChallengeContext);
        Py_VISIT(state->type_SmartCardConnection);
        Py_VISIT(state->type_SmartCardCryptogramGenerator);
        Py_VISIT(state->type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult);
        Py_VISIT(state->type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult);
        Py_VISIT(state->type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult);
        Py_VISIT(state->type_SmartCardCryptogramMaterialCharacteristics);
        Py_VISIT(state->type_SmartCardCryptogramMaterialPackageCharacteristics);
        Py_VISIT(state->type_SmartCardCryptogramMaterialPossessionProof);
        Py_VISIT(state->type_SmartCardCryptogramPlacementStep);
        Py_VISIT(state->type_SmartCardCryptogramStorageKeyCharacteristics);
        Py_VISIT(state->type_SmartCardCryptogramStorageKeyInfo);
        Py_VISIT(state->type_SmartCardEmulator);
        Py_VISIT(state->type_SmartCardEmulatorApduReceivedEventArgs);
        Py_VISIT(state->type_SmartCardEmulatorConnectionDeactivatedEventArgs);
        Py_VISIT(state->type_SmartCardEmulatorConnectionProperties);
        Py_VISIT(state->type_SmartCardPinPolicy);
        Py_VISIT(state->type_SmartCardPinResetDeferral);
        Py_VISIT(state->type_SmartCardPinResetRequest);
        Py_VISIT(state->type_SmartCardProvisioning);
        Py_VISIT(state->type_SmartCardReader);
        Py_VISIT(state->type_SmartCardTriggerDetails);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_SmartCardActivationPolicyChangeResult);
        Py_CLEAR(state->type_SmartCardAppletIdGroupActivationPolicy);
        Py_CLEAR(state->type_SmartCardAutomaticResponseStatus);
        Py_CLEAR(state->type_SmartCardCryptogramAlgorithm);
        Py_CLEAR(state->type_SmartCardCryptogramGeneratorOperationStatus);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialPackageFormat);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialProtectionMethod);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialType);
        Py_CLEAR(state->type_SmartCardCryptogramPlacementOptions);
        Py_CLEAR(state->type_SmartCardCryptogramStorageKeyAlgorithm);
        Py_CLEAR(state->type_SmartCardCryptogramStorageKeyCapabilities);
        Py_CLEAR(state->type_SmartCardCryptographicKeyAttestationStatus);
        Py_CLEAR(state->type_SmartCardEmulationCategory);
        Py_CLEAR(state->type_SmartCardEmulationType);
        Py_CLEAR(state->type_SmartCardEmulatorConnectionDeactivatedReason);
        Py_CLEAR(state->type_SmartCardEmulatorConnectionSource);
        Py_CLEAR(state->type_SmartCardEmulatorEnablementPolicy);
        Py_CLEAR(state->type_SmartCardLaunchBehavior);
        Py_CLEAR(state->type_SmartCardPinCharacterPolicyOption);
        Py_CLEAR(state->type_SmartCardReaderKind);
        Py_CLEAR(state->type_SmartCardReaderStatus);
        Py_CLEAR(state->type_SmartCardStatus);
        Py_CLEAR(state->type_SmartCardTriggerType);
        Py_CLEAR(state->type_SmartCardUnlockPromptingBehavior);
        Py_CLEAR(state->type_CardAddedEventArgs);
        Py_CLEAR(state->type_CardRemovedEventArgs);
        Py_CLEAR(state->type_KnownSmartCardAppletIds);
        Py_CLEAR(state->type_SmartCard);
        Py_CLEAR(state->type_SmartCardAppletIdGroup);
        Py_CLEAR(state->type_SmartCardAppletIdGroupRegistration);
        Py_CLEAR(state->type_SmartCardAutomaticResponseApdu);
        Py_CLEAR(state->type_SmartCardChallengeContext);
        Py_CLEAR(state->type_SmartCardConnection);
        Py_CLEAR(state->type_SmartCardCryptogramGenerator);
        Py_CLEAR(state->type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult);
        Py_CLEAR(state->type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult);
        Py_CLEAR(state->type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialCharacteristics);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialPackageCharacteristics);
        Py_CLEAR(state->type_SmartCardCryptogramMaterialPossessionProof);
        Py_CLEAR(state->type_SmartCardCryptogramPlacementStep);
        Py_CLEAR(state->type_SmartCardCryptogramStorageKeyCharacteristics);
        Py_CLEAR(state->type_SmartCardCryptogramStorageKeyInfo);
        Py_CLEAR(state->type_SmartCardEmulator);
        Py_CLEAR(state->type_SmartCardEmulatorApduReceivedEventArgs);
        Py_CLEAR(state->type_SmartCardEmulatorConnectionDeactivatedEventArgs);
        Py_CLEAR(state->type_SmartCardEmulatorConnectionProperties);
        Py_CLEAR(state->type_SmartCardPinPolicy);
        Py_CLEAR(state->type_SmartCardPinResetDeferral);
        Py_CLEAR(state->type_SmartCardPinResetRequest);
        Py_CLEAR(state->type_SmartCardProvisioning);
        Py_CLEAR(state->type_SmartCardReader);
        Py_CLEAR(state->type_SmartCardTriggerDetails);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_SmartCards",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::SmartCards

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_SmartCards(void) noexcept
{
    using namespace py::cpp::Windows::Devices::SmartCards;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_CardAddedEventArgs = py::register_python_type(module.get(), type_name_CardAddedEventArgs, &type_spec_CardAddedEventArgs, bases.get(), nullptr);
    if (!state->type_CardAddedEventArgs)
    {
        return nullptr;
    }

    state->type_CardRemovedEventArgs = py::register_python_type(module.get(), type_name_CardRemovedEventArgs, &type_spec_CardRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_CardRemovedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownSmartCardAppletIds_Meta{PyType_FromSpec(&type_spec_KnownSmartCardAppletIds_Meta)};
    if (!type_KnownSmartCardAppletIds_Meta)
    {
        return nullptr;
    }

    state->type_KnownSmartCardAppletIds = py::register_python_type(module.get(), type_name_KnownSmartCardAppletIds, &type_spec_KnownSmartCardAppletIds, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownSmartCardAppletIds_Meta.get()));
    if (!state->type_KnownSmartCardAppletIds)
    {
        return nullptr;
    }

    state->type_SmartCard = py::register_python_type(module.get(), type_name_SmartCard, &type_spec_SmartCard, bases.get(), nullptr);
    if (!state->type_SmartCard)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardAppletIdGroup_Meta{PyType_FromSpec(&type_spec_SmartCardAppletIdGroup_Meta)};
    if (!type_SmartCardAppletIdGroup_Meta)
    {
        return nullptr;
    }

    state->type_SmartCardAppletIdGroup = py::register_python_type(module.get(), type_name_SmartCardAppletIdGroup, &type_spec_SmartCardAppletIdGroup, bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardAppletIdGroup_Meta.get()));
    if (!state->type_SmartCardAppletIdGroup)
    {
        return nullptr;
    }

    state->type_SmartCardAppletIdGroupRegistration = py::register_python_type(module.get(), type_name_SmartCardAppletIdGroupRegistration, &type_spec_SmartCardAppletIdGroupRegistration, bases.get(), nullptr);
    if (!state->type_SmartCardAppletIdGroupRegistration)
    {
        return nullptr;
    }

    state->type_SmartCardAutomaticResponseApdu = py::register_python_type(module.get(), type_name_SmartCardAutomaticResponseApdu, &type_spec_SmartCardAutomaticResponseApdu, bases.get(), nullptr);
    if (!state->type_SmartCardAutomaticResponseApdu)
    {
        return nullptr;
    }

    state->type_SmartCardChallengeContext = py::register_python_type(module.get(), type_name_SmartCardChallengeContext, &type_spec_SmartCardChallengeContext, bases.get(), nullptr);
    if (!state->type_SmartCardChallengeContext)
    {
        return nullptr;
    }

    state->type_SmartCardConnection = py::register_python_type(module.get(), type_name_SmartCardConnection, &type_spec_SmartCardConnection, bases.get(), nullptr);
    if (!state->type_SmartCardConnection)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramGenerator = py::register_python_type(module.get(), type_name_SmartCardCryptogramGenerator, &type_spec_SmartCardCryptogramGenerator, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramGenerator)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult = py::register_python_type(module.get(), type_name_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, &type_spec_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult = py::register_python_type(module.get(), type_name_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, &type_spec_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult = py::register_python_type(module.get(), type_name_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, &type_spec_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramMaterialCharacteristics = py::register_python_type(module.get(), type_name_SmartCardCryptogramMaterialCharacteristics, &type_spec_SmartCardCryptogramMaterialCharacteristics, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramMaterialCharacteristics)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramMaterialPackageCharacteristics = py::register_python_type(module.get(), type_name_SmartCardCryptogramMaterialPackageCharacteristics, &type_spec_SmartCardCryptogramMaterialPackageCharacteristics, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramMaterialPackageCharacteristics)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramMaterialPossessionProof = py::register_python_type(module.get(), type_name_SmartCardCryptogramMaterialPossessionProof, &type_spec_SmartCardCryptogramMaterialPossessionProof, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramMaterialPossessionProof)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramPlacementStep = py::register_python_type(module.get(), type_name_SmartCardCryptogramPlacementStep, &type_spec_SmartCardCryptogramPlacementStep, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramPlacementStep)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramStorageKeyCharacteristics = py::register_python_type(module.get(), type_name_SmartCardCryptogramStorageKeyCharacteristics, &type_spec_SmartCardCryptogramStorageKeyCharacteristics, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramStorageKeyCharacteristics)
    {
        return nullptr;
    }

    state->type_SmartCardCryptogramStorageKeyInfo = py::register_python_type(module.get(), type_name_SmartCardCryptogramStorageKeyInfo, &type_spec_SmartCardCryptogramStorageKeyInfo, bases.get(), nullptr);
    if (!state->type_SmartCardCryptogramStorageKeyInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardEmulator_Meta{PyType_FromSpec(&type_spec_SmartCardEmulator_Meta)};
    if (!type_SmartCardEmulator_Meta)
    {
        return nullptr;
    }

    state->type_SmartCardEmulator = py::register_python_type(module.get(), type_name_SmartCardEmulator, &type_spec_SmartCardEmulator, bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardEmulator_Meta.get()));
    if (!state->type_SmartCardEmulator)
    {
        return nullptr;
    }

    state->type_SmartCardEmulatorApduReceivedEventArgs = py::register_python_type(module.get(), type_name_SmartCardEmulatorApduReceivedEventArgs, &type_spec_SmartCardEmulatorApduReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_SmartCardEmulatorApduReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_SmartCardEmulatorConnectionDeactivatedEventArgs = py::register_python_type(module.get(), type_name_SmartCardEmulatorConnectionDeactivatedEventArgs, &type_spec_SmartCardEmulatorConnectionDeactivatedEventArgs, bases.get(), nullptr);
    if (!state->type_SmartCardEmulatorConnectionDeactivatedEventArgs)
    {
        return nullptr;
    }

    state->type_SmartCardEmulatorConnectionProperties = py::register_python_type(module.get(), type_name_SmartCardEmulatorConnectionProperties, &type_spec_SmartCardEmulatorConnectionProperties, bases.get(), nullptr);
    if (!state->type_SmartCardEmulatorConnectionProperties)
    {
        return nullptr;
    }

    state->type_SmartCardPinPolicy = py::register_python_type(module.get(), type_name_SmartCardPinPolicy, &type_spec_SmartCardPinPolicy, bases.get(), nullptr);
    if (!state->type_SmartCardPinPolicy)
    {
        return nullptr;
    }

    state->type_SmartCardPinResetDeferral = py::register_python_type(module.get(), type_name_SmartCardPinResetDeferral, &type_spec_SmartCardPinResetDeferral, bases.get(), nullptr);
    if (!state->type_SmartCardPinResetDeferral)
    {
        return nullptr;
    }

    state->type_SmartCardPinResetRequest = py::register_python_type(module.get(), type_name_SmartCardPinResetRequest, &type_spec_SmartCardPinResetRequest, bases.get(), nullptr);
    if (!state->type_SmartCardPinResetRequest)
    {
        return nullptr;
    }

    state->type_SmartCardProvisioning = py::register_python_type(module.get(), type_name_SmartCardProvisioning, &type_spec_SmartCardProvisioning, bases.get(), nullptr);
    if (!state->type_SmartCardProvisioning)
    {
        return nullptr;
    }

    state->type_SmartCardReader = py::register_python_type(module.get(), type_name_SmartCardReader, &type_spec_SmartCardReader, bases.get(), nullptr);
    if (!state->type_SmartCardReader)
    {
        return nullptr;
    }

    state->type_SmartCardTriggerDetails = py::register_python_type(module.get(), type_name_SmartCardTriggerDetails, &type_spec_SmartCardTriggerDetails, bases.get(), nullptr);
    if (!state->type_SmartCardTriggerDetails)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardActivationPolicyChangeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardActivationPolicyChangeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardActivationPolicyChangeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupActivationPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardAppletIdGroupActivationPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupActivationPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardAutomaticResponseStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramAlgorithm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramAlgorithm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramAlgorithm is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGeneratorOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramGeneratorOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramGeneratorOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageConfirmationResponseFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialPackageConfirmationResponseFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageConfirmationResponseFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialPackageFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialProtectionMethod>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialProtectionMethod;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialProtectionMethod is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramPlacementOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyAlgorithm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramStorageKeyAlgorithm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyAlgorithm is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramStorageKeyCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptographicKeyAttestationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptographicKeyAttestationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptographicKeyAttestationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulationCategory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorConnectionDeactivatedReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorConnectionSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorEnablementPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorEnablementPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorEnablementPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardLaunchBehavior>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardLaunchBehavior;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardLaunchBehavior is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardPinCharacterPolicyOption;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardReaderKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardReaderKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardReaderKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardReaderStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardReaderStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardReaderStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardTriggerType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardTriggerType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardTriggerType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardUnlockPromptingBehavior;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CardAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::CardAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CardRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::CardRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownSmartCardAppletIds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCard>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCard;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCard is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardAppletIdGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardAppletIdGroupRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardAutomaticResponseApdu;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardChallengeContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardChallengeContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramGenerator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialCharacteristics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialPackageCharacteristics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramMaterialPossessionProof;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramPlacementStep;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramStorageKeyCharacteristics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardCryptogramStorageKeyInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardEmulator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulator is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorApduReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorConnectionDeactivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardEmulatorConnectionProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardPinPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardPinPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardPinResetDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardPinResetRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardProvisioning;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardProvisioning is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::SmartCards;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::SmartCards");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartCardTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}
