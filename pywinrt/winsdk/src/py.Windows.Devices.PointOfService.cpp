// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.PointOfService.h"


PyObject* py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert(winrt::Windows::Devices::PointOfService::SizeUInt32 instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Devices::PointOfService::SizeUInt32 py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::PointOfService::SizeUInt32");
    throw python_exception();
}

namespace py::cpp::Windows::Devices::PointOfService
{
    struct module_state
    {
        PyObject* type_BarcodeScannerStatus;
        PyObject* type_BarcodeSymbologyDecodeLengthKind;
        PyObject* type_CashDrawerStatusKind;
        PyObject* type_LineDisplayCursorType;
        PyObject* type_LineDisplayDescriptorState;
        PyObject* type_LineDisplayHorizontalAlignment;
        PyObject* type_LineDisplayMarqueeFormat;
        PyObject* type_LineDisplayPowerStatus;
        PyObject* type_LineDisplayScrollDirection;
        PyObject* type_LineDisplayTextAttribute;
        PyObject* type_LineDisplayTextAttributeGranularity;
        PyObject* type_LineDisplayVerticalAlignment;
        PyObject* type_MagneticStripeReaderAuthenticationLevel;
        PyObject* type_MagneticStripeReaderAuthenticationProtocol;
        PyObject* type_MagneticStripeReaderErrorReportingType;
        PyObject* type_MagneticStripeReaderStatus;
        PyObject* type_MagneticStripeReaderTrackErrorType;
        PyObject* type_MagneticStripeReaderTrackIds;
        PyObject* type_PosConnectionTypes;
        PyObject* type_PosPrinterAlignment;
        PyObject* type_PosPrinterBarcodeTextPosition;
        PyObject* type_PosPrinterCartridgeSensors;
        PyObject* type_PosPrinterColorCapabilities;
        PyObject* type_PosPrinterColorCartridge;
        PyObject* type_PosPrinterLineDirection;
        PyObject* type_PosPrinterLineStyle;
        PyObject* type_PosPrinterMapMode;
        PyObject* type_PosPrinterMarkFeedCapabilities;
        PyObject* type_PosPrinterMarkFeedKind;
        PyObject* type_PosPrinterPrintSide;
        PyObject* type_PosPrinterRotation;
        PyObject* type_PosPrinterRuledLineCapabilities;
        PyObject* type_PosPrinterStatusKind;
        PyObject* type_UnifiedPosErrorReason;
        PyObject* type_UnifiedPosErrorSeverity;
        PyObject* type_UnifiedPosHealthCheckLevel;
        PyObject* type_UnifiedPosPowerReportingType;
        PyTypeObject* type_BarcodeScanner;
        PyTypeObject* type_BarcodeScannerCapabilities;
        PyTypeObject* type_BarcodeScannerDataReceivedEventArgs;
        PyTypeObject* type_BarcodeScannerErrorOccurredEventArgs;
        PyTypeObject* type_BarcodeScannerImagePreviewReceivedEventArgs;
        PyTypeObject* type_BarcodeScannerReport;
        PyTypeObject* type_BarcodeScannerStatusUpdatedEventArgs;
        PyTypeObject* type_BarcodeSymbologies;
        PyTypeObject* type_BarcodeSymbologyAttributes;
        PyTypeObject* type_CashDrawer;
        PyTypeObject* type_CashDrawerCapabilities;
        PyTypeObject* type_CashDrawerCloseAlarm;
        PyTypeObject* type_CashDrawerClosedEventArgs;
        PyTypeObject* type_CashDrawerEventSource;
        PyTypeObject* type_CashDrawerOpenedEventArgs;
        PyTypeObject* type_CashDrawerStatus;
        PyTypeObject* type_CashDrawerStatusUpdatedEventArgs;
        PyTypeObject* type_ClaimedBarcodeScanner;
        PyTypeObject* type_ClaimedBarcodeScannerClosedEventArgs;
        PyTypeObject* type_ClaimedCashDrawer;
        PyTypeObject* type_ClaimedCashDrawerClosedEventArgs;
        PyTypeObject* type_ClaimedJournalPrinter;
        PyTypeObject* type_ClaimedLineDisplay;
        PyTypeObject* type_ClaimedLineDisplayClosedEventArgs;
        PyTypeObject* type_ClaimedMagneticStripeReader;
        PyTypeObject* type_ClaimedMagneticStripeReaderClosedEventArgs;
        PyTypeObject* type_ClaimedPosPrinter;
        PyTypeObject* type_ClaimedPosPrinterClosedEventArgs;
        PyTypeObject* type_ClaimedReceiptPrinter;
        PyTypeObject* type_ClaimedSlipPrinter;
        PyTypeObject* type_JournalPrintJob;
        PyTypeObject* type_JournalPrinterCapabilities;
        PyTypeObject* type_LineDisplay;
        PyTypeObject* type_LineDisplayAttributes;
        PyTypeObject* type_LineDisplayCapabilities;
        PyTypeObject* type_LineDisplayCursor;
        PyTypeObject* type_LineDisplayCursorAttributes;
        PyTypeObject* type_LineDisplayCustomGlyphs;
        PyTypeObject* type_LineDisplayMarquee;
        PyTypeObject* type_LineDisplayStatisticsCategorySelector;
        PyTypeObject* type_LineDisplayStatusUpdatedEventArgs;
        PyTypeObject* type_LineDisplayStoredBitmap;
        PyTypeObject* type_LineDisplayWindow;
        PyTypeObject* type_MagneticStripeReader;
        PyTypeObject* type_MagneticStripeReaderAamvaCardDataReceivedEventArgs;
        PyTypeObject* type_MagneticStripeReaderBankCardDataReceivedEventArgs;
        PyTypeObject* type_MagneticStripeReaderCapabilities;
        PyTypeObject* type_MagneticStripeReaderCardTypes;
        PyTypeObject* type_MagneticStripeReaderEncryptionAlgorithms;
        PyTypeObject* type_MagneticStripeReaderErrorOccurredEventArgs;
        PyTypeObject* type_MagneticStripeReaderReport;
        PyTypeObject* type_MagneticStripeReaderStatusUpdatedEventArgs;
        PyTypeObject* type_MagneticStripeReaderTrackData;
        PyTypeObject* type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs;
        PyTypeObject* type_PosPrinter;
        PyTypeObject* type_PosPrinterCapabilities;
        PyTypeObject* type_PosPrinterCharacterSetIds;
        PyTypeObject* type_PosPrinterFontProperty;
        PyTypeObject* type_PosPrinterPrintOptions;
        PyTypeObject* type_PosPrinterReleaseDeviceRequestedEventArgs;
        PyTypeObject* type_PosPrinterStatus;
        PyTypeObject* type_PosPrinterStatusUpdatedEventArgs;
        PyTypeObject* type_ReceiptPrintJob;
        PyTypeObject* type_ReceiptPrinterCapabilities;
        PyTypeObject* type_SlipPrintJob;
        PyTypeObject* type_SlipPrinterCapabilities;
        PyTypeObject* type_UnifiedPosErrorData;
        PyTypeObject* type_ICashDrawerEventSourceEventArgs;
        PyTypeObject* type_ICommonClaimedPosPrinterStation;
        PyTypeObject* type_ICommonPosPrintStationCapabilities;
        PyTypeObject* type_ICommonReceiptSlipCapabilities;
        PyTypeObject* type_IPosPrinterJob;
        PyTypeObject* type_IReceiptOrSlipJob;
        PyTypeObject* type_SizeUInt32;
    };

    static PyObject* register_BarcodeScannerStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BarcodeScannerStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BarcodeScannerStatus = type;
        Py_INCREF(state->type_BarcodeScannerStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_BarcodeSymbologyDecodeLengthKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BarcodeSymbologyDecodeLengthKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BarcodeSymbologyDecodeLengthKind = type;
        Py_INCREF(state->type_BarcodeSymbologyDecodeLengthKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_CashDrawerStatusKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CashDrawerStatusKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CashDrawerStatusKind = type;
        Py_INCREF(state->type_CashDrawerStatusKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayCursorType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayCursorType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayCursorType = type;
        Py_INCREF(state->type_LineDisplayCursorType);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayDescriptorState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayDescriptorState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayDescriptorState = type;
        Py_INCREF(state->type_LineDisplayDescriptorState);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayHorizontalAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayHorizontalAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayHorizontalAlignment = type;
        Py_INCREF(state->type_LineDisplayHorizontalAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayMarqueeFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayMarqueeFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayMarqueeFormat = type;
        Py_INCREF(state->type_LineDisplayMarqueeFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayPowerStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayPowerStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayPowerStatus = type;
        Py_INCREF(state->type_LineDisplayPowerStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayScrollDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayScrollDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayScrollDirection = type;
        Py_INCREF(state->type_LineDisplayScrollDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayTextAttribute(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayTextAttribute)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayTextAttribute = type;
        Py_INCREF(state->type_LineDisplayTextAttribute);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayTextAttributeGranularity(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayTextAttributeGranularity)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayTextAttributeGranularity = type;
        Py_INCREF(state->type_LineDisplayTextAttributeGranularity);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineDisplayVerticalAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_LineDisplayVerticalAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineDisplayVerticalAlignment = type;
        Py_INCREF(state->type_LineDisplayVerticalAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderAuthenticationLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderAuthenticationLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderAuthenticationLevel = type;
        Py_INCREF(state->type_MagneticStripeReaderAuthenticationLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderAuthenticationProtocol(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderAuthenticationProtocol)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderAuthenticationProtocol = type;
        Py_INCREF(state->type_MagneticStripeReaderAuthenticationProtocol);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderErrorReportingType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderErrorReportingType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderErrorReportingType = type;
        Py_INCREF(state->type_MagneticStripeReaderErrorReportingType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderStatus = type;
        Py_INCREF(state->type_MagneticStripeReaderStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderTrackErrorType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderTrackErrorType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderTrackErrorType = type;
        Py_INCREF(state->type_MagneticStripeReaderTrackErrorType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MagneticStripeReaderTrackIds(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MagneticStripeReaderTrackIds)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MagneticStripeReaderTrackIds = type;
        Py_INCREF(state->type_MagneticStripeReaderTrackIds);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosConnectionTypes(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosConnectionTypes)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosConnectionTypes = type;
        Py_INCREF(state->type_PosConnectionTypes);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterAlignment = type;
        Py_INCREF(state->type_PosPrinterAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterBarcodeTextPosition(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterBarcodeTextPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterBarcodeTextPosition = type;
        Py_INCREF(state->type_PosPrinterBarcodeTextPosition);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterCartridgeSensors(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterCartridgeSensors)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterCartridgeSensors = type;
        Py_INCREF(state->type_PosPrinterCartridgeSensors);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterColorCapabilities(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterColorCapabilities)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterColorCapabilities = type;
        Py_INCREF(state->type_PosPrinterColorCapabilities);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterColorCartridge(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterColorCartridge)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterColorCartridge = type;
        Py_INCREF(state->type_PosPrinterColorCartridge);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterLineDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterLineDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterLineDirection = type;
        Py_INCREF(state->type_PosPrinterLineDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterLineStyle(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterLineStyle)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterLineStyle = type;
        Py_INCREF(state->type_PosPrinterLineStyle);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterMapMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterMapMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterMapMode = type;
        Py_INCREF(state->type_PosPrinterMapMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterMarkFeedCapabilities(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterMarkFeedCapabilities)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterMarkFeedCapabilities = type;
        Py_INCREF(state->type_PosPrinterMarkFeedCapabilities);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterMarkFeedKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterMarkFeedKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterMarkFeedKind = type;
        Py_INCREF(state->type_PosPrinterMarkFeedKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterPrintSide(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterPrintSide)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterPrintSide = type;
        Py_INCREF(state->type_PosPrinterPrintSide);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterRotation(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterRotation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterRotation = type;
        Py_INCREF(state->type_PosPrinterRotation);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterRuledLineCapabilities(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterRuledLineCapabilities)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterRuledLineCapabilities = type;
        Py_INCREF(state->type_PosPrinterRuledLineCapabilities);


        Py_RETURN_NONE;
    }

    static PyObject* register_PosPrinterStatusKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PosPrinterStatusKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PosPrinterStatusKind = type;
        Py_INCREF(state->type_PosPrinterStatusKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_UnifiedPosErrorReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UnifiedPosErrorReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UnifiedPosErrorReason = type;
        Py_INCREF(state->type_UnifiedPosErrorReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_UnifiedPosErrorSeverity(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UnifiedPosErrorSeverity)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UnifiedPosErrorSeverity = type;
        Py_INCREF(state->type_UnifiedPosErrorSeverity);


        Py_RETURN_NONE;
    }

    static PyObject* register_UnifiedPosHealthCheckLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UnifiedPosHealthCheckLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UnifiedPosHealthCheckLevel = type;
        Py_INCREF(state->type_UnifiedPosHealthCheckLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_UnifiedPosPowerReportingType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UnifiedPosPowerReportingType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UnifiedPosPowerReportingType = type;
        Py_INCREF(state->type_UnifiedPosPowerReportingType);


        Py_RETURN_NONE;
    }

    // ----- BarcodeScanner class --------------------
    static constexpr const char* const type_name_BarcodeScanner = "BarcodeScanner";

    static PyObject* _new_BarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScanner);
        return nullptr;
    }

    static void _dealloc_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScanner_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"CheckHealthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_ClaimScannerAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"ClaimScannerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClaimScannerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedProfiles(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetSupportedProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetSupportedSymbologiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedSymbologiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsProfileSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"IsProfileSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsSymbologySupportedAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"IsSymbologySupportedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsSymbologySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"RetrieveStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_VideoDeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"VideoDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::BarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScanner[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(BarcodeScanner_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_scanner_async", reinterpret_cast<PyCFunction>(BarcodeScanner_ClaimScannerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(BarcodeScanner_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BarcodeScanner_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_profiles", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedProfiles), METH_VARARGS, nullptr },
        { "get_supported_symbologies_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedSymbologiesAsync), METH_VARARGS, nullptr },
        { "is_profile_supported", reinterpret_cast<PyCFunction>(BarcodeScanner_IsProfileSupported), METH_VARARGS, nullptr },
        { "is_symbology_supported_async", reinterpret_cast<PyCFunction>(BarcodeScanner_IsSymbologySupportedAsync), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(BarcodeScanner_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_BarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScanner[] = {
        { "capabilities", reinterpret_cast<getter>(BarcodeScanner_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(BarcodeScanner_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScanner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScanner) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScanner =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScanner
    };

    // ----- BarcodeScannerCapabilities class --------------------
    static constexpr const char* const type_name_BarcodeScannerCapabilities = "BarcodeScannerCapabilities";

    static PyObject* _new_BarcodeScannerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerCapabilities);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerCapabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerCapabilities_get_IsImagePreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsImagePreviewSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsImagePreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsStatisticsReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsStatisticsUpdatingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"PowerReportingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsSoftwareTriggerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSoftwareTriggerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsVideoPreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsVideoPreviewSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoPreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerCapabilities[] = {
        { "_assign_array_", _assign_array_BarcodeScannerCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerCapabilities[] = {
        { "is_image_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsImagePreviewSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "is_software_trigger_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported), nullptr, nullptr, nullptr },
        { "is_video_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsVideoPreviewSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerCapabilities) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerCapabilities
    };

    // ----- BarcodeScannerDataReceivedEventArgs class --------------------
    static constexpr const char* const type_name_BarcodeScannerDataReceivedEventArgs = "BarcodeScannerDataReceivedEventArgs";

    static PyObject* _new_BarcodeScannerDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs", L"Report"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(BarcodeScannerDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerDataReceivedEventArgs
    };

    // ----- BarcodeScannerErrorOccurredEventArgs class --------------------
    static constexpr const char* const type_name_BarcodeScannerErrorOccurredEventArgs = "BarcodeScannerErrorOccurredEventArgs";

    static PyObject* _new_BarcodeScannerErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"ErrorData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_IsRetriable(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"IsRetriable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRetriable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"PartialInputData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "is_retriable", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_IsRetriable), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerErrorOccurredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerErrorOccurredEventArgs
    };

    // ----- BarcodeScannerImagePreviewReceivedEventArgs class --------------------
    static constexpr const char* const type_name_BarcodeScannerImagePreviewReceivedEventArgs = "BarcodeScannerImagePreviewReceivedEventArgs";

    static PyObject* _new_BarcodeScannerImagePreviewReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerImagePreviewReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerImagePreviewReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerImagePreviewReceivedEventArgs_get_Preview(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs", L"Preview"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerImagePreviewReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerImagePreviewReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "preview", reinterpret_cast<getter>(BarcodeScannerImagePreviewReceivedEventArgs_get_Preview), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerImagePreviewReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerImagePreviewReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerImagePreviewReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerImagePreviewReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerImagePreviewReceivedEventArgs
    };

    // ----- BarcodeScannerReport class --------------------
    static constexpr const char* const type_name_BarcodeScannerReport = "BarcodeScannerReport";

    static PyObject* _new_BarcodeScannerReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                winrt::Windows::Devices::PointOfService::BarcodeScannerReport instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BarcodeScannerReport(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerReport_get_ScanData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataLabel(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanDataLabel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanDataLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanDataType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanDataType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerReport[] = {
        { "_assign_array_", _assign_array_BarcodeScannerReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerReport[] = {
        { "scan_data", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanData), nullptr, nullptr, nullptr },
        { "scan_data_label", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataLabel), nullptr, nullptr, nullptr },
        { "scan_data_type", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerReport) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerReport =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerReport
    };

    // ----- BarcodeScannerStatusUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_BarcodeScannerStatusUpdatedEventArgs = "BarcodeScannerStatusUpdatedEventArgs";

    static PyObject* _new_BarcodeScannerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs", L"ExtendedStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerStatusUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerStatusUpdatedEventArgs
    };

    // ----- BarcodeSymbologies class --------------------
    static constexpr const char* const type_name_BarcodeSymbologies = "BarcodeSymbologies";

    static PyObject* _new_BarcodeSymbologies(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeSymbologies);
        return nullptr;
    }

    static PyObject* BarcodeSymbologies_GetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"GetName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::GetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code11(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code11"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_AusPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"AusPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::AusPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Aztec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Aztec"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Aztec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CanPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ccab"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ccc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ChinaPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ChinaPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ChinaPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codabar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Codabar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codabar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codablock128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Codablock128"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codablock128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CodablockA"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CodablockF"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DutchKix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DutchKix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DutchKix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code128"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code16k(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code16k"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code16k());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code32"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code39"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code39Ex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code49(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code49"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code49());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code93"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code93Ex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DataCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataMatrix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DataMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPostNet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsPostNet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPostNet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13Add2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13Add5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8Add2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8Add5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99Add2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99Add5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Eanv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Eanv"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Eanv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"EanvAdd2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"EanvAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ExtendedBase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1128"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128Coupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1128Coupon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128Coupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_HanXin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"HanXin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::HanXin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_InfoMail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"InfoMail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::InfoMail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Isbn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsbnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsbnAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsbnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Isbt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ismn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ismn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ismn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsmnAdd2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsmnAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Issn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Issn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Issn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IssnAdd2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IssnAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ItalianPost25"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ItalianPost39"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_JapanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"JapanPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::JapanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_KoreanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"KoreanPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::KoreanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Maxicode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Maxicode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Maxicode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Micr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Micr"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Micr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroPdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MicroPdf417"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroPdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroQr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MicroQr"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroQr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MsTag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MsTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MsTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Msi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Msi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Msi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"OcrA"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"OcrB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Pdf417"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Plessey(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Plessey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Plessey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pzn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Pzn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pzn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Qr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Qr"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Qr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Sisac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Sisac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Sisac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_SwedenPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"SwedenPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::SwedenPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Telepen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Telepen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Telepen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfDis(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfDis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfDis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfIata(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfIata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfIata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfInd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfInt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfMat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfMat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfMat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfStd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfStd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfStd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Tlc39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Tlc39"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Tlc39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Trioptic39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Trioptic39"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Trioptic39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UccEan128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UccEan128"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UccEan128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UkPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UkPost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UkPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Unknown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcCoupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcCoupon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcCoupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upca(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Upca"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upca());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcaAdd2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcaAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upce(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Upce"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpceAdd2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpceAdd5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Us4StateFics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Us4StateFics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Us4StateFics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsIntelligent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligentPkg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsIntelligentPkg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligentPkg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPlanet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsPlanet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPlanet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DWCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DWCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DWCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologies[] = {
        { "get_name", reinterpret_cast<PyCFunction>(BarcodeSymbologies_GetName), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologies[] = {
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologies[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeSymbologies) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeSymbologies) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeSymbologies) },
        { },
    };

    static PyType_Spec type_spec_BarcodeSymbologies =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeSymbologies",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologies
    };

    static PyGetSetDef getset_BarcodeSymbologies_Meta[] = {
        { "code11", reinterpret_cast<getter>(BarcodeSymbologies_get_Code11), nullptr, nullptr, nullptr },
        { "aus_post", reinterpret_cast<getter>(BarcodeSymbologies_get_AusPost), nullptr, nullptr, nullptr },
        { "aztec", reinterpret_cast<getter>(BarcodeSymbologies_get_Aztec), nullptr, nullptr, nullptr },
        { "can_post", reinterpret_cast<getter>(BarcodeSymbologies_get_CanPost), nullptr, nullptr, nullptr },
        { "ccab", reinterpret_cast<getter>(BarcodeSymbologies_get_Ccab), nullptr, nullptr, nullptr },
        { "ccc", reinterpret_cast<getter>(BarcodeSymbologies_get_Ccc), nullptr, nullptr, nullptr },
        { "china_post", reinterpret_cast<getter>(BarcodeSymbologies_get_ChinaPost), nullptr, nullptr, nullptr },
        { "codabar", reinterpret_cast<getter>(BarcodeSymbologies_get_Codabar), nullptr, nullptr, nullptr },
        { "codablock128", reinterpret_cast<getter>(BarcodeSymbologies_get_Codablock128), nullptr, nullptr, nullptr },
        { "codablock_a", reinterpret_cast<getter>(BarcodeSymbologies_get_CodablockA), nullptr, nullptr, nullptr },
        { "codablock_f", reinterpret_cast<getter>(BarcodeSymbologies_get_CodablockF), nullptr, nullptr, nullptr },
        { "dutch_kix", reinterpret_cast<getter>(BarcodeSymbologies_get_DutchKix), nullptr, nullptr, nullptr },
        { "code128", reinterpret_cast<getter>(BarcodeSymbologies_get_Code128), nullptr, nullptr, nullptr },
        { "code16k", reinterpret_cast<getter>(BarcodeSymbologies_get_Code16k), nullptr, nullptr, nullptr },
        { "code32", reinterpret_cast<getter>(BarcodeSymbologies_get_Code32), nullptr, nullptr, nullptr },
        { "code39", reinterpret_cast<getter>(BarcodeSymbologies_get_Code39), nullptr, nullptr, nullptr },
        { "code39_ex", reinterpret_cast<getter>(BarcodeSymbologies_get_Code39Ex), nullptr, nullptr, nullptr },
        { "code49", reinterpret_cast<getter>(BarcodeSymbologies_get_Code49), nullptr, nullptr, nullptr },
        { "code93", reinterpret_cast<getter>(BarcodeSymbologies_get_Code93), nullptr, nullptr, nullptr },
        { "code93_ex", reinterpret_cast<getter>(BarcodeSymbologies_get_Code93Ex), nullptr, nullptr, nullptr },
        { "data_code", reinterpret_cast<getter>(BarcodeSymbologies_get_DataCode), nullptr, nullptr, nullptr },
        { "data_matrix", reinterpret_cast<getter>(BarcodeSymbologies_get_DataMatrix), nullptr, nullptr, nullptr },
        { "us_post_net", reinterpret_cast<getter>(BarcodeSymbologies_get_UsPostNet), nullptr, nullptr, nullptr },
        { "ean13", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13), nullptr, nullptr, nullptr },
        { "ean13_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13Add2), nullptr, nullptr, nullptr },
        { "ean13_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13Add5), nullptr, nullptr, nullptr },
        { "ean8", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8), nullptr, nullptr, nullptr },
        { "ean8_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8Add2), nullptr, nullptr, nullptr },
        { "ean8_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8Add5), nullptr, nullptr, nullptr },
        { "ean99", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99), nullptr, nullptr, nullptr },
        { "ean99_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99Add2), nullptr, nullptr, nullptr },
        { "ean99_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99Add5), nullptr, nullptr, nullptr },
        { "eanv", reinterpret_cast<getter>(BarcodeSymbologies_get_Eanv), nullptr, nullptr, nullptr },
        { "eanv_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_EanvAdd2), nullptr, nullptr, nullptr },
        { "eanv_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_EanvAdd5), nullptr, nullptr, nullptr },
        { "extended_base", reinterpret_cast<getter>(BarcodeSymbologies_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "gs1128", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1128), nullptr, nullptr, nullptr },
        { "gs1128_coupon", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1128Coupon), nullptr, nullptr, nullptr },
        { "gs1_databar_type1", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType1), nullptr, nullptr, nullptr },
        { "gs1_databar_type2", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType2), nullptr, nullptr, nullptr },
        { "gs1_databar_type3", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType3), nullptr, nullptr, nullptr },
        { "han_xin", reinterpret_cast<getter>(BarcodeSymbologies_get_HanXin), nullptr, nullptr, nullptr },
        { "info_mail", reinterpret_cast<getter>(BarcodeSymbologies_get_InfoMail), nullptr, nullptr, nullptr },
        { "isbn", reinterpret_cast<getter>(BarcodeSymbologies_get_Isbn), nullptr, nullptr, nullptr },
        { "isbn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IsbnAdd5), nullptr, nullptr, nullptr },
        { "isbt", reinterpret_cast<getter>(BarcodeSymbologies_get_Isbt), nullptr, nullptr, nullptr },
        { "ismn", reinterpret_cast<getter>(BarcodeSymbologies_get_Ismn), nullptr, nullptr, nullptr },
        { "ismn_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_IsmnAdd2), nullptr, nullptr, nullptr },
        { "ismn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IsmnAdd5), nullptr, nullptr, nullptr },
        { "issn", reinterpret_cast<getter>(BarcodeSymbologies_get_Issn), nullptr, nullptr, nullptr },
        { "issn_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_IssnAdd2), nullptr, nullptr, nullptr },
        { "issn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IssnAdd5), nullptr, nullptr, nullptr },
        { "italian_post25", reinterpret_cast<getter>(BarcodeSymbologies_get_ItalianPost25), nullptr, nullptr, nullptr },
        { "italian_post39", reinterpret_cast<getter>(BarcodeSymbologies_get_ItalianPost39), nullptr, nullptr, nullptr },
        { "japan_post", reinterpret_cast<getter>(BarcodeSymbologies_get_JapanPost), nullptr, nullptr, nullptr },
        { "korean_post", reinterpret_cast<getter>(BarcodeSymbologies_get_KoreanPost), nullptr, nullptr, nullptr },
        { "maxicode", reinterpret_cast<getter>(BarcodeSymbologies_get_Maxicode), nullptr, nullptr, nullptr },
        { "micr", reinterpret_cast<getter>(BarcodeSymbologies_get_Micr), nullptr, nullptr, nullptr },
        { "micro_pdf417", reinterpret_cast<getter>(BarcodeSymbologies_get_MicroPdf417), nullptr, nullptr, nullptr },
        { "micro_qr", reinterpret_cast<getter>(BarcodeSymbologies_get_MicroQr), nullptr, nullptr, nullptr },
        { "ms_tag", reinterpret_cast<getter>(BarcodeSymbologies_get_MsTag), nullptr, nullptr, nullptr },
        { "msi", reinterpret_cast<getter>(BarcodeSymbologies_get_Msi), nullptr, nullptr, nullptr },
        { "ocr_a", reinterpret_cast<getter>(BarcodeSymbologies_get_OcrA), nullptr, nullptr, nullptr },
        { "ocr_b", reinterpret_cast<getter>(BarcodeSymbologies_get_OcrB), nullptr, nullptr, nullptr },
        { "pdf417", reinterpret_cast<getter>(BarcodeSymbologies_get_Pdf417), nullptr, nullptr, nullptr },
        { "plessey", reinterpret_cast<getter>(BarcodeSymbologies_get_Plessey), nullptr, nullptr, nullptr },
        { "pzn", reinterpret_cast<getter>(BarcodeSymbologies_get_Pzn), nullptr, nullptr, nullptr },
        { "qr", reinterpret_cast<getter>(BarcodeSymbologies_get_Qr), nullptr, nullptr, nullptr },
        { "sisac", reinterpret_cast<getter>(BarcodeSymbologies_get_Sisac), nullptr, nullptr, nullptr },
        { "sweden_post", reinterpret_cast<getter>(BarcodeSymbologies_get_SwedenPost), nullptr, nullptr, nullptr },
        { "telepen", reinterpret_cast<getter>(BarcodeSymbologies_get_Telepen), nullptr, nullptr, nullptr },
        { "tf_dis", reinterpret_cast<getter>(BarcodeSymbologies_get_TfDis), nullptr, nullptr, nullptr },
        { "tf_iata", reinterpret_cast<getter>(BarcodeSymbologies_get_TfIata), nullptr, nullptr, nullptr },
        { "tf_ind", reinterpret_cast<getter>(BarcodeSymbologies_get_TfInd), nullptr, nullptr, nullptr },
        { "tf_int", reinterpret_cast<getter>(BarcodeSymbologies_get_TfInt), nullptr, nullptr, nullptr },
        { "tf_mat", reinterpret_cast<getter>(BarcodeSymbologies_get_TfMat), nullptr, nullptr, nullptr },
        { "tf_std", reinterpret_cast<getter>(BarcodeSymbologies_get_TfStd), nullptr, nullptr, nullptr },
        { "tlc39", reinterpret_cast<getter>(BarcodeSymbologies_get_Tlc39), nullptr, nullptr, nullptr },
        { "trioptic39", reinterpret_cast<getter>(BarcodeSymbologies_get_Trioptic39), nullptr, nullptr, nullptr },
        { "ucc_ean128", reinterpret_cast<getter>(BarcodeSymbologies_get_UccEan128), nullptr, nullptr, nullptr },
        { "uk_post", reinterpret_cast<getter>(BarcodeSymbologies_get_UkPost), nullptr, nullptr, nullptr },
        { "unknown", reinterpret_cast<getter>(BarcodeSymbologies_get_Unknown), nullptr, nullptr, nullptr },
        { "upc_coupon", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcCoupon), nullptr, nullptr, nullptr },
        { "upca", reinterpret_cast<getter>(BarcodeSymbologies_get_Upca), nullptr, nullptr, nullptr },
        { "upca_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcaAdd2), nullptr, nullptr, nullptr },
        { "upca_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcaAdd5), nullptr, nullptr, nullptr },
        { "upce", reinterpret_cast<getter>(BarcodeSymbologies_get_Upce), nullptr, nullptr, nullptr },
        { "upce_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_UpceAdd2), nullptr, nullptr, nullptr },
        { "upce_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_UpceAdd5), nullptr, nullptr, nullptr },
        { "us4_state_fics", reinterpret_cast<getter>(BarcodeSymbologies_get_Us4StateFics), nullptr, nullptr, nullptr },
        { "us_intelligent", reinterpret_cast<getter>(BarcodeSymbologies_get_UsIntelligent), nullptr, nullptr, nullptr },
        { "us_intelligent_pkg", reinterpret_cast<getter>(BarcodeSymbologies_get_UsIntelligentPkg), nullptr, nullptr, nullptr },
        { "us_planet", reinterpret_cast<getter>(BarcodeSymbologies_get_UsPlanet), nullptr, nullptr, nullptr },
        { "gs1_d_w_code", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DWCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BarcodeSymbologies_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BarcodeSymbologies_Meta) },
        { }
    };

    static PyType_Spec type_spec_BarcodeSymbologies_Meta =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeSymbologies_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BarcodeSymbologies_Meta
    };

    // ----- BarcodeSymbologyAttributes class --------------------
    static constexpr const char* const type_name_BarcodeSymbologyAttributes = "BarcodeSymbologyAttributes";

    static PyObject* _new_BarcodeSymbologyAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeSymbologyAttributes);
        return nullptr;
    }

    static void _dealloc_BarcodeSymbologyAttributes(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCheckDigitValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitTransmissionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLengthKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodeLengthKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLengthKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind>(arg);

            self->obj.DecodeLengthKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodeLength2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodeLength1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCheckDigitValidationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsDecodeLengthSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsDecodeLengthSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDecodeLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologyAttributes[] = {
        { "_assign_array_", _assign_array_BarcodeSymbologyAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeSymbologyAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologyAttributes[] = {
        { "is_check_digit_validation_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled), nullptr, nullptr },
        { "is_check_digit_transmission_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled), nullptr, nullptr },
        { "decode_length_kind", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLengthKind), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLengthKind), nullptr, nullptr },
        { "decode_length2", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength2), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength2), nullptr, nullptr },
        { "decode_length1", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength1), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength1), nullptr, nullptr },
        { "is_check_digit_transmission_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported), nullptr, nullptr, nullptr },
        { "is_check_digit_validation_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported), nullptr, nullptr, nullptr },
        { "is_decode_length_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsDecodeLengthSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologyAttributes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeSymbologyAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeSymbologyAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeSymbologyAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeSymbologyAttributes) },
        { },
    };

    static PyType_Spec type_spec_BarcodeSymbologyAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeSymbologyAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologyAttributes
    };

    // ----- CashDrawer class --------------------
    static constexpr const char* const type_name_CashDrawer = "CashDrawer";

    static PyObject* _new_CashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawer);
        return nullptr;
    }

    static void _dealloc_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawer_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"CheckHealthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_ClaimDrawerAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"ClaimDrawerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClaimDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"DrawerEventSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DrawerEventSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"IsDrawerOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawer", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawer, winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawer", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawer[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(CashDrawer_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_drawer_async", reinterpret_cast<PyCFunction>(CashDrawer_ClaimDrawerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CashDrawer_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(CashDrawer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(CashDrawer_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(CashDrawer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(CashDrawer_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CashDrawer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawer[] = {
        { "capabilities", reinterpret_cast<getter>(CashDrawer_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(CashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "drawer_event_source", reinterpret_cast<getter>(CashDrawer_get_DrawerEventSource), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(CashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CashDrawer_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawer) },
        { },
    };

    static PyType_Spec type_spec_CashDrawer =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawer
    };

    // ----- CashDrawerCapabilities class --------------------
    static constexpr const char* const type_name_CashDrawerCapabilities = "CashDrawerCapabilities";

    static PyObject* _new_CashDrawerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerCapabilities);
        return nullptr;
    }

    static void _dealloc_CashDrawerCapabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsDrawerOpenSensorAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDrawerOpenSensorAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatisticsReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatisticsUpdatingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatusMultiDrawerDetectSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatusMultiDrawerDetectSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatusReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatusReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"PowerReportingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCapabilities[] = {
        { "_assign_array_", _assign_array_CashDrawerCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCapabilities[] = {
        { "is_drawer_open_sensor_available", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_status_multi_drawer_detect_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported), nullptr, nullptr, nullptr },
        { "is_status_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusReportingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(CashDrawerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerCapabilities) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCapabilities
    };

    // ----- CashDrawerCloseAlarm class --------------------
    static constexpr const char* const type_name_CashDrawerCloseAlarm = "CashDrawerCloseAlarm";

    static PyObject* _new_CashDrawerCloseAlarm(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerCloseAlarm);
        return nullptr;
    }

    static void _dealloc_CashDrawerCloseAlarm(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerCloseAlarm_StartAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepFrequency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BeepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepFrequency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BeepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BeepDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BeepDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlarmTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AlarmTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_add_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeoutExpired"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AlarmTimeoutExpired(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_remove_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeoutExpired"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AlarmTimeoutExpired(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCloseAlarm[] = {
        { "start_async", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_StartAsync), METH_VARARGS, nullptr },
        { "add_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_add_AlarmTimeoutExpired), METH_O, nullptr },
        { "remove_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_remove_AlarmTimeoutExpired), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawerCloseAlarm, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCloseAlarm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCloseAlarm[] = {
        { "beep_frequency", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepFrequency), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepFrequency), nullptr, nullptr },
        { "beep_duration", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDuration), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDuration), nullptr, nullptr },
        { "beep_delay", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDelay), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDelay), nullptr, nullptr },
        { "alarm_timeout", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_AlarmTimeout), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_AlarmTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCloseAlarm[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerCloseAlarm) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerCloseAlarm) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerCloseAlarm) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerCloseAlarm) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerCloseAlarm =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerCloseAlarm",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCloseAlarm
    };

    // ----- CashDrawerClosedEventArgs class --------------------
    static constexpr const char* const type_name_CashDrawerClosedEventArgs = "CashDrawerClosedEventArgs";

    static PyObject* _new_CashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerClosedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerClosedEventArgs", L"CashDrawer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerClosedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerClosedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerClosedEventArgs
    };

    // ----- CashDrawerEventSource class --------------------
    static constexpr const char* const type_name_CashDrawerEventSource = "CashDrawerEventSource";

    static PyObject* _new_CashDrawerEventSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerEventSource);
        return nullptr;
    }

    static void _dealloc_CashDrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerEventSource_add_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.DrawerClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_add_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>(arg);

            return py::convert(self->obj.DrawerOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerEventSource[] = {
        { "add_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerClosed), METH_O, nullptr },
        { "remove_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerClosed), METH_O, nullptr },
        { "add_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerOpened), METH_O, nullptr },
        { "remove_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawerEventSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerEventSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerEventSource[] = {
        { }
    };

    static PyType_Slot _type_slots_CashDrawerEventSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerEventSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerEventSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerEventSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerEventSource) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerEventSource =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerEventSource",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerEventSource
    };

    // ----- CashDrawerOpenedEventArgs class --------------------
    static constexpr const char* const type_name_CashDrawerOpenedEventArgs = "CashDrawerOpenedEventArgs";

    static PyObject* _new_CashDrawerOpenedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerOpenedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerOpenedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerOpenedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerOpenedEventArgs", L"CashDrawer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerOpenedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerOpenedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerOpenedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerOpenedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerOpenedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerOpenedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerOpenedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerOpenedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerOpenedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerOpenedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerOpenedEventArgs
    };

    // ----- CashDrawerStatus class --------------------
    static constexpr const char* const type_name_CashDrawerStatus = "CashDrawerStatus";

    static PyObject* _new_CashDrawerStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerStatus);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatus", L"ExtendedStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatus", L"StatusKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatus[] = {
        { "_assign_array_", _assign_array_CashDrawerStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatus[] = {
        { "extended_status", reinterpret_cast<getter>(CashDrawerStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(CashDrawerStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerStatus) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerStatus =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatus
    };

    // ----- CashDrawerStatusUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_CashDrawerStatusUpdatedEventArgs = "CashDrawerStatusUpdatedEventArgs";

    static PyObject* _new_CashDrawerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CashDrawerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(CashDrawerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerStatusUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CashDrawerStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatusUpdatedEventArgs
    };

    // ----- ClaimedBarcodeScanner class --------------------
    static constexpr const char* const type_name_ClaimedBarcodeScanner = "ClaimedBarcodeScanner";

    static PyObject* _new_ClaimedBarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedBarcodeScanner);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedBarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_GetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"GetSymbologyAttributesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetSymbologyAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_HideVideoPreview(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"HideVideoPreview", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.HideVideoPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ResetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"RetainDevice", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveProfileAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetActiveProfileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetActiveProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetActiveSymbologiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.SetActiveSymbologiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetSymbologyAttributesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>(args, 1);

                return py::convert(self->obj.SetSymbologyAttributesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ShowVideoPreviewAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ShowVideoPreviewAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShowVideoPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StartSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"StartSoftwareTriggerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StopSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"StopSoftwareTriggerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"UpdateStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDisabledOnDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDisabledOnDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDecodeDataEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDecodeDataEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsVideoPreviewShownOnEnable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoPreviewShownOnEnable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsVideoPreviewShownOnEnable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoPreviewShownOnEnable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ImagePreviewReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>(arg);

            return py::convert(self->obj.ImagePreviewReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ImagePreviewReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImagePreviewReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScanner[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_EnableAsync), METH_VARARGS, nullptr },
        { "get_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_GetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "hide_video_preview", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_HideVideoPreview), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_RetainDevice), METH_VARARGS, nullptr },
        { "set_active_profile_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveProfileAsync), METH_VARARGS, nullptr },
        { "set_active_symbologies_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveSymbologiesAsync), METH_VARARGS, nullptr },
        { "set_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "show_video_preview_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ShowVideoPreviewAsync), METH_VARARGS, nullptr },
        { "start_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StartSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "stop_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StopSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_DataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ErrorOccurred), METH_O, nullptr },
        { "add_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ImagePreviewReceived), METH_O, nullptr },
        { "remove_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ImagePreviewReceived), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerPressed), METH_O, nullptr },
        { "remove_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerPressed), METH_O, nullptr },
        { "add_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerReleased), METH_O, nullptr },
        { "remove_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerReleased), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedBarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedBarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedBarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScanner[] = {
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_video_preview_shown_on_enable", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScanner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedBarcodeScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedBarcodeScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedBarcodeScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedBarcodeScanner) },
        { },
    };

    static PyType_Spec type_spec_ClaimedBarcodeScanner =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedBarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScanner
    };

    // ----- ClaimedBarcodeScannerClosedEventArgs class --------------------
    static constexpr const char* const type_name_ClaimedBarcodeScannerClosedEventArgs = "ClaimedBarcodeScannerClosedEventArgs";

    static PyObject* _new_ClaimedBarcodeScannerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedBarcodeScannerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScannerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScannerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedBarcodeScannerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScannerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScannerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScannerClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedBarcodeScannerClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClaimedBarcodeScannerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedBarcodeScannerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScannerClosedEventArgs
    };

    // ----- ClaimedCashDrawer class --------------------
    static constexpr const char* const type_name_ClaimedCashDrawer = "ClaimedCashDrawer";

    static PyObject* _new_ClaimedCashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedCashDrawer);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedCashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_OpenDrawerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"OpenDrawerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ResetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"RetainDeviceAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"UpdateStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_CloseAlarm(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"CloseAlarm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CloseAlarm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"IsDrawerOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawer[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_EnableAsync), METH_VARARGS, nullptr },
        { "open_drawer_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_OpenDrawerAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedCashDrawer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedCashDrawer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedCashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawer[] = {
        { "close_alarm", reinterpret_cast<getter>(ClaimedCashDrawer_get_CloseAlarm), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedCashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedCashDrawer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedCashDrawer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedCashDrawer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedCashDrawer) },
        { },
    };

    static PyType_Spec type_spec_ClaimedCashDrawer =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedCashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawer
    };

    // ----- ClaimedCashDrawerClosedEventArgs class --------------------
    static constexpr const char* const type_name_ClaimedCashDrawerClosedEventArgs = "ClaimedCashDrawerClosedEventArgs";

    static PyObject* _new_ClaimedCashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedCashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedCashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedCashDrawerClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClaimedCashDrawerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedCashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawerClosedEventArgs
    };

    // ----- ClaimedJournalPrinter class --------------------
    static constexpr const char* const type_name_ClaimedJournalPrinter = "ClaimedJournalPrinter";

    static PyObject* _new_ClaimedJournalPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedJournalPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedJournalPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedJournalPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CreateJob", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ValidateData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCartridgeEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCartridgeRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCoverOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsHeadCleaning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsPaperEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsPaperNearEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsReadyToPrint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedJournalPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedJournalPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedJournalPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedJournalPrinter[] = {
        { "line_spacing", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedJournalPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedJournalPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedJournalPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedJournalPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedJournalPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedJournalPrinter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedJournalPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedJournalPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedJournalPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedJournalPrinter) },
        { },
    };

    static PyType_Spec type_spec_ClaimedJournalPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedJournalPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedJournalPrinter
    };

    // ----- ClaimedLineDisplay class --------------------
    static constexpr const char* const type_name_ClaimedLineDisplay = "ClaimedLineDisplay";

    static PyObject* _new_ClaimedLineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedLineDisplay);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedLineDisplay_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CheckHealthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CheckPowerStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetAttributes(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetAttributes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"RetainDevice", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryClearDescriptorsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryClearDescriptorsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryClearDescriptorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryCreateWindowAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryCreateWindowAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(self->obj.TryCreateWindowAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TrySetDescriptorAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TrySetDescriptorAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState>(args, 1);

                return py::convert(self->obj.TrySetDescriptorAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryStoreStorageFileBitmapAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryUpdateAttributesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DefaultWindow(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DefaultWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceControlDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceControlVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceServiceVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"PhysicalDeviceDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"PhysicalDeviceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_CustomGlyphs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CustomGlyphs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_MaxBitmapSizeInPixels(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"MaxBitmapSizeInPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBitmapSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"SupportedCharacterSets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedScreenSizesInCharacters(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"SupportedScreenSizesInCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedScreenSizesInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplay[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckHealthAsync), METH_VARARGS, nullptr },
        { "check_power_status_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_attributes", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetAttributes), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_RetainDevice), METH_VARARGS, nullptr },
        { "try_clear_descriptors_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryClearDescriptorsAsync), METH_VARARGS, nullptr },
        { "try_create_window_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryCreateWindowAsync), METH_VARARGS, nullptr },
        { "try_set_descriptor_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TrySetDescriptorAsync), METH_VARARGS, nullptr },
        { "try_store_storage_file_bitmap_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryStoreStorageFileBitmapAsync), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_StatusUpdated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedLineDisplay, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedLineDisplay), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedLineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(ClaimedLineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "default_window", reinterpret_cast<getter>(ClaimedLineDisplay_get_DefaultWindow), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { "custom_glyphs", reinterpret_cast<getter>(ClaimedLineDisplay_get_CustomGlyphs), nullptr, nullptr, nullptr },
        { "max_bitmap_size_in_pixels", reinterpret_cast<getter>(ClaimedLineDisplay_get_MaxBitmapSizeInPixels), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_screen_sizes_in_characters", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedScreenSizesInCharacters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplay[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedLineDisplay) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedLineDisplay) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedLineDisplay) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedLineDisplay) },
        { },
    };

    static PyType_Spec type_spec_ClaimedLineDisplay =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedLineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplay
    };

    // ----- ClaimedLineDisplayClosedEventArgs class --------------------
    static constexpr const char* const type_name_ClaimedLineDisplayClosedEventArgs = "ClaimedLineDisplayClosedEventArgs";

    static PyObject* _new_ClaimedLineDisplayClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedLineDisplayClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplayClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplayClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedLineDisplayClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplayClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplayClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplayClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedLineDisplayClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClaimedLineDisplayClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedLineDisplayClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplayClosedEventArgs
    };

    // ----- ClaimedMagneticStripeReader class --------------------
    static constexpr const char* const type_name_ClaimedMagneticStripeReader = "ClaimedMagneticStripeReader";

    static PyObject* _new_ClaimedMagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedMagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedMagneticStripeReader_AuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AuthenticateDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.AuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DeAuthenticateDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.DeAuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ResetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"RetainDevice", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"RetrieveDeviceAuthenticationDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RetrieveDeviceAuthenticationDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_SetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"SetErrorReportingType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType>(args, 0);

                self->obj.SetErrorReportingType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateKeyAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"UpdateKeyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UpdateKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"UpdateStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"TracksToRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TracksToRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"TracksToRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds>(arg);

            self->obj.TracksToRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsTransmitSentinelsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmitSentinelsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsTransmitSentinelsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransmitSentinelsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDisabledOnDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDisabledOnDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDecodeDataEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDecodeDataEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DataEncryptionAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DataEncryptionAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DataEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDeviceAuthenticated(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDeviceAuthenticated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDeviceAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AamvaCardDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.AamvaCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AamvaCardDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AamvaCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"BankCardDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.BankCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"BankCardDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BankCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"VendorSpecificDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.VendorSpecificDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"VendorSpecificDataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VendorSpecificDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReader[] = {
        { "authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_AuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "de_authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetainDevice), METH_VARARGS, nullptr },
        { "retrieve_device_authentication_data_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync), METH_VARARGS, nullptr },
        { "set_error_reporting_type", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_SetErrorReportingType), METH_VARARGS, nullptr },
        { "update_key_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateKeyAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_AamvaCardDataReceived), METH_O, nullptr },
        { "remove_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_AamvaCardDataReceived), METH_O, nullptr },
        { "add_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_BankCardDataReceived), METH_O, nullptr },
        { "remove_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_BankCardDataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ErrorOccurred), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_VendorSpecificDataReceived), METH_O, nullptr },
        { "remove_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedMagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedMagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedMagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReader[] = {
        { "tracks_to_read", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_TracksToRead), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_TracksToRead), nullptr, nullptr },
        { "is_transmit_sentinels_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled), nullptr, nullptr },
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "data_encryption_algorithm", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_device_authenticated", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDeviceAuthenticated), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedMagneticStripeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedMagneticStripeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedMagneticStripeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedMagneticStripeReader) },
        { },
    };

    static PyType_Spec type_spec_ClaimedMagneticStripeReader =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedMagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReader
    };

    // ----- ClaimedMagneticStripeReaderClosedEventArgs class --------------------
    static constexpr const char* const type_name_ClaimedMagneticStripeReaderClosedEventArgs = "ClaimedMagneticStripeReaderClosedEventArgs";

    static PyObject* _new_ClaimedMagneticStripeReaderClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedMagneticStripeReaderClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReaderClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedMagneticStripeReaderClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReaderClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReaderClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedMagneticStripeReaderClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClaimedMagneticStripeReaderClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedMagneticStripeReaderClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReaderClosedEventArgs
    };

    // ----- ClaimedPosPrinter class --------------------
    static constexpr const char* const type_name_ClaimedPosPrinter = "ClaimedPosPrinter";

    static PyObject* _new_ClaimedPosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedPosPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedPosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ResetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"RetainDeviceAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"UpdateStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"MapMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"MapMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMapMode>(arg);

            self->obj.MapMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCharacterSetMappingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCharacterSetMappingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCoverOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Journal(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Journal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Receipt(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Receipt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Slip(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Slip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ReleaseDeviceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinter[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedPosPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedPosPrinter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedPosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinter[] = {
        { "map_mode", reinterpret_cast<getter>(ClaimedPosPrinter_get_MapMode), reinterpret_cast<setter>(ClaimedPosPrinter_put_MapMode), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(ClaimedPosPrinter_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(ClaimedPosPrinter_get_CharacterSet), reinterpret_cast<setter>(ClaimedPosPrinter_put_CharacterSet), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedPosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsEnabled), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(ClaimedPosPrinter_get_Journal), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(ClaimedPosPrinter_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(ClaimedPosPrinter_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedPosPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedPosPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedPosPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedPosPrinter) },
        { },
    };

    static PyType_Spec type_spec_ClaimedPosPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedPosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinter
    };

    // ----- ClaimedPosPrinterClosedEventArgs class --------------------
    static constexpr const char* const type_name_ClaimedPosPrinterClosedEventArgs = "ClaimedPosPrinterClosedEventArgs";

    static PyObject* _new_ClaimedPosPrinterClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedPosPrinterClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinterClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinterClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedPosPrinterClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinterClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinterClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinterClosedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedPosPrinterClosedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ClaimedPosPrinterClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedPosPrinterClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinterClosedEventArgs
    };

    // ----- ClaimedReceiptPrinter class --------------------
    static constexpr const char* const type_name_ClaimedReceiptPrinter = "ClaimedReceiptPrinter";

    static PyObject* _new_ClaimedReceiptPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedReceiptPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedReceiptPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedReceiptPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CreateJob", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ValidateData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LinesToPaperCut(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LinesToPaperCut"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinesToPaperCut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"PrintArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"SidewaysMaxChars"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"SidewaysMaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCartridgeEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCartridgeRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCoverOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsHeadCleaning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsPaperEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsPaperNearEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsReadyToPrint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedReceiptPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedReceiptPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedReceiptPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedReceiptPrinter[] = {
        { "lines_to_paper_cut", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LinesToPaperCut), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedReceiptPrinter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedReceiptPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedReceiptPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedReceiptPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedReceiptPrinter) },
        { },
    };

    static PyType_Spec type_spec_ClaimedReceiptPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedReceiptPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedReceiptPrinter
    };

    // ----- ClaimedSlipPrinter class --------------------
    static constexpr const char* const type_name_ClaimedSlipPrinter = "ClaimedSlipPrinter";

    static PyObject* _new_ClaimedSlipPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ClaimedSlipPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedSlipPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedSlipPrinter_ChangePrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ChangePrintSide", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintSide>(args, 0);

                self->obj.ChangePrintSide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CloseJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CloseJaws", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CreateJob", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_InsertSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"InsertSlipAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.InsertSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_OpenJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"OpenJaws", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OpenJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_RemoveSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"RemoveSlipAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.RemoveSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ValidateData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LinesNearEndToEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LinesNearEndToEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinesNearEndToEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_MaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"MaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PrintArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PrintSide"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrintSide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"SidewaysMaxChars"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"SidewaysMaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCartridgeEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCartridgeRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCoverOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsHeadCleaning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsPaperEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsPaperNearEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsReadyToPrint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedSlipPrinter[] = {
        { "change_print_side", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ChangePrintSide), METH_VARARGS, nullptr },
        { "close_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CloseJaws), METH_VARARGS, nullptr },
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CreateJob), METH_VARARGS, nullptr },
        { "insert_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_InsertSlipAsync), METH_VARARGS, nullptr },
        { "open_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_OpenJaws), METH_VARARGS, nullptr },
        { "remove_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_RemoveSlipAsync), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedSlipPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedSlipPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedSlipPrinter[] = {
        { "lines_near_end_to_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LinesNearEndToEnd), nullptr, nullptr, nullptr },
        { "max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_MaxLines), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "print_side", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintSide), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedSlipPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedSlipPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedSlipPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedSlipPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedSlipPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedSlipPrinter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedSlipPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedSlipPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedSlipPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedSlipPrinter) },
        { },
    };

    static PyType_Spec type_spec_ClaimedSlipPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedSlipPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedSlipPrinter
    };

    // ----- JournalPrintJob class --------------------
    static constexpr const char* const type_name_JournalPrintJob = "JournalPrintJob";

    static PyObject* _new_JournalPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_JournalPrintJob);
        return nullptr;
    }

    static void _dealloc_JournalPrintJob(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JournalPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"ExecuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"FeedPaperByLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"FeedPaperByMapModeUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"Print", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"Print", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"PrintLine", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"PrintLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::JournalPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrintJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(JournalPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(JournalPrintJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(JournalPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JournalPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_JournalPrintJob[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JournalPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JournalPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JournalPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JournalPrintJob) },
        { },
    };

    static PyType_Spec type_spec_JournalPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.JournalPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrintJob
    };

    // ----- JournalPrinterCapabilities class --------------------
    static constexpr const char* const type_name_JournalPrinterCapabilities = "JournalPrinterCapabilities";

    static PyObject* _new_JournalPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_JournalPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_JournalPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JournalPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"CartridgeSensors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"ColorCartridgeCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsBoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleHighPrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDualColorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsItalicSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPaperEmptySensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPrinterPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"SupportedCharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReverseVideoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsStrikethroughSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsSubscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsSuperscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_JournalPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(JournalPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(JournalPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(JournalPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JournalPrinterCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JournalPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JournalPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JournalPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JournalPrinterCapabilities) },
        { },
    };

    static PyType_Spec type_spec_JournalPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.JournalPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrinterCapabilities
    };

    // ----- LineDisplay class --------------------
    static constexpr const char* const type_name_LineDisplay = "LineDisplay";

    static PyObject* _new_LineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplay);
        return nullptr;
    }

    static void _dealloc_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"CheckPowerStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_ClaimAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"ClaimAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClaimAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceControlDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceControlVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceServiceVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"PhysicalDeviceDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"PhysicalDeviceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_StatisticsCategorySelector(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"StatisticsCategorySelector"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::StatisticsCategorySelector());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplay>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplay[] = {
        { "check_power_status_async", reinterpret_cast<PyCFunction>(LineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "claim_async", reinterpret_cast<PyCFunction>(LineDisplay_ClaimAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(LineDisplay_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(LineDisplay_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(LineDisplay_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(LineDisplay_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_LineDisplay, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplay), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(LineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(LineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(LineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(LineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(LineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplay[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplay) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplay) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplay) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplay) },
        { },
    };

    static PyType_Spec type_spec_LineDisplay =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplay
    };

    static PyGetSetDef getset_LineDisplay_Meta[] = {
        { "statistics_category_selector", reinterpret_cast<getter>(LineDisplay_get_StatisticsCategorySelector), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_LineDisplay_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineDisplay_Meta) },
        { }
    };

    static PyType_Spec type_spec_LineDisplay_Meta =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplay_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineDisplay_Meta
    };

    // ----- LineDisplayAttributes class --------------------
    static constexpr const char* const type_name_LineDisplayAttributes = "LineDisplayAttributes";

    static PyObject* _new_LineDisplayAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayAttributes_get_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"ScreenSizeInCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScreenSizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"ScreenSizeInCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.ScreenSizeInCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsPowerNotifyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPowerNotifyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsPowerNotifyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPowerNotifyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsCharacterSetMappingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsCharacterSetMappingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CurrentWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CurrentWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayWindow>(arg);

            self->obj.CurrentWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"BlinkRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"BlinkRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BlinkRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayAttributes[] = {
        { "_assign_array_", _assign_array_LineDisplayAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayAttributes[] = {
        { "screen_size_in_characters", reinterpret_cast<getter>(LineDisplayAttributes_get_ScreenSizeInCharacters), reinterpret_cast<setter>(LineDisplayAttributes_put_ScreenSizeInCharacters), nullptr, nullptr },
        { "is_power_notify_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsPowerNotifyEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsPowerNotifyEnabled), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "current_window", reinterpret_cast<getter>(LineDisplayAttributes_get_CurrentWindow), reinterpret_cast<setter>(LineDisplayAttributes_put_CurrentWindow), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(LineDisplayAttributes_get_CharacterSet), reinterpret_cast<setter>(LineDisplayAttributes_put_CharacterSet), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(LineDisplayAttributes_get_Brightness), reinterpret_cast<setter>(LineDisplayAttributes_put_Brightness), nullptr, nullptr },
        { "blink_rate", reinterpret_cast<getter>(LineDisplayAttributes_get_BlinkRate), reinterpret_cast<setter>(LineDisplayAttributes_put_BlinkRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayAttributes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayAttributes) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayAttributes
    };

    // ----- LineDisplayCapabilities class --------------------
    static constexpr const char* const type_name_LineDisplayCapabilities = "LineDisplayCapabilities";

    static PyObject* _new_LineDisplayCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayCapabilities);
        return nullptr;
    }

    static void _dealloc_LineDisplayCapabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCapabilities_get_CanBlink(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanBlink"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanBlink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeBlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanChangeBlinkRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanChangeBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeScreenSize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanChangeScreenSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanChangeScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayBitmaps(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanDisplayBitmaps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDisplayBitmaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanDisplayCustomGlyphs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDisplayCustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanMapCharacterSets(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanMapCharacterSets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMapCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReadCharacterAtCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanReadCharacterAtCursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanReadCharacterAtCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReverse(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanReverse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanReverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsBrightnessSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsBrightnessSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBrightnessSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsCursorSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsCursorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCursorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsHorizontalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsHorizontalMarqueeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHorizontalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsInterCharacterWaitSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsInterCharacterWaitSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterCharacterWaitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsStatisticsReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsStatisticsUpdatingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsVerticalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsVerticalMarqueeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVerticalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"PowerReportingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedDescriptors(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"SupportedDescriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedDescriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedWindows(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"SupportedWindows"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedWindows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCapabilities[] = {
        { "_assign_array_", _assign_array_LineDisplayCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCapabilities[] = {
        { "can_blink", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanBlink), nullptr, nullptr, nullptr },
        { "can_change_blink_rate", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeBlinkRate), nullptr, nullptr, nullptr },
        { "can_change_screen_size", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeScreenSize), nullptr, nullptr, nullptr },
        { "can_display_bitmaps", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayBitmaps), nullptr, nullptr, nullptr },
        { "can_display_custom_glyphs", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayCustomGlyphs), nullptr, nullptr, nullptr },
        { "can_map_character_sets", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanMapCharacterSets), nullptr, nullptr, nullptr },
        { "can_read_character_at_cursor", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReadCharacterAtCursor), nullptr, nullptr, nullptr },
        { "can_reverse", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReverse), nullptr, nullptr, nullptr },
        { "is_brightness_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsBrightnessSupported), nullptr, nullptr, nullptr },
        { "is_cursor_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsCursorSupported), nullptr, nullptr, nullptr },
        { "is_horizontal_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsHorizontalMarqueeSupported), nullptr, nullptr, nullptr },
        { "is_inter_character_wait_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsInterCharacterWaitSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_vertical_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsVerticalMarqueeSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(LineDisplayCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_descriptors", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedDescriptors), nullptr, nullptr, nullptr },
        { "supported_windows", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedWindows), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCapabilities) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCapabilities
    };

    // ----- LineDisplayCursor class --------------------
    static constexpr const char* const type_name_LineDisplayCursor = "LineDisplayCursor";

    static PyObject* _new_LineDisplayCursor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayCursor);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCursor_GetAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"GetAttributes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"TryUpdateAttributesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_CanCustomize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"CanCustomize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanCustomize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlinkSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsBlinkSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBlinkSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsBlockSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsHalfBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsHalfBlockSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHalfBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsOtherSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsOtherSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOtherSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsReverseSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsReverseSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReverseSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursor[] = {
        { "get_attributes", reinterpret_cast<PyCFunction>(LineDisplayCursor_GetAttributes), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(LineDisplayCursor_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursor[] = {
        { "can_customize", reinterpret_cast<getter>(LineDisplayCursor_get_CanCustomize), nullptr, nullptr, nullptr },
        { "is_blink_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlinkSupported), nullptr, nullptr, nullptr },
        { "is_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlockSupported), nullptr, nullptr, nullptr },
        { "is_half_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsHalfBlockSupported), nullptr, nullptr, nullptr },
        { "is_other_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsOtherSupported), nullptr, nullptr, nullptr },
        { "is_reverse_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsReverseSupported), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCursor) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayCursor =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCursor",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursor
    };

    // ----- LineDisplayCursorAttributes class --------------------
    static constexpr const char* const type_name_LineDisplayCursorAttributes = "LineDisplayCursorAttributes";

    static PyObject* _new_LineDisplayCursorAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayCursorAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursorAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCursorAttributes_get_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsBlinkEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBlinkEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsBlinkEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBlinkEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsAutoAdvanceEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAutoAdvanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsAutoAdvanceEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoAdvanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"CursorType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"CursorType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorType>(arg);

            self->obj.CursorType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursorAttributes[] = {
        { "_assign_array_", _assign_array_LineDisplayCursorAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursorAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursorAttributes[] = {
        { "position", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_Position), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_Position), nullptr, nullptr },
        { "is_blink_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsBlinkEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsBlinkEnabled), nullptr, nullptr },
        { "is_auto_advance_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled), nullptr, nullptr },
        { "cursor_type", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_CursorType), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_CursorType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursorAttributes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCursorAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCursorAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCursorAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCursorAttributes) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayCursorAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCursorAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursorAttributes
    };

    // ----- LineDisplayCustomGlyphs class --------------------
    static constexpr const char* const type_name_LineDisplayCustomGlyphs = "LineDisplayCustomGlyphs";

    static PyObject* _new_LineDisplayCustomGlyphs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayCustomGlyphs);
        return nullptr;
    }

    static void _dealloc_LineDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCustomGlyphs_TryRedefineAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"TryRedefineAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.TryRedefineAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SizeInPixels(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"SizeInPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SupportedGlyphCodes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"SupportedGlyphCodes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedGlyphCodes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCustomGlyphs[] = {
        { "try_redefine_async", reinterpret_cast<PyCFunction>(LineDisplayCustomGlyphs_TryRedefineAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayCustomGlyphs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCustomGlyphs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCustomGlyphs[] = {
        { "size_in_pixels", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SizeInPixels), nullptr, nullptr, nullptr },
        { "supported_glyph_codes", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SupportedGlyphCodes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCustomGlyphs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCustomGlyphs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCustomGlyphs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCustomGlyphs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCustomGlyphs) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayCustomGlyphs =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCustomGlyphs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCustomGlyphs
    };

    // ----- LineDisplayMarquee class --------------------
    static constexpr const char* const type_name_LineDisplayMarquee = "LineDisplayMarquee";

    static PyObject* _new_LineDisplayMarquee(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayMarquee);
        return nullptr;
    }

    static void _dealloc_LineDisplayMarquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayMarquee_TryStartScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"TryStartScrollingAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);

                return py::convert(self->obj.TryStartScrollingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_TryStopScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"TryStopScrollingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryStopScrollingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_get_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"ScrollWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"ScrollWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.ScrollWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"RepeatWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepeatWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"RepeatWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepeatWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayMarquee[] = {
        { "try_start_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStartScrollingAsync), METH_VARARGS, nullptr },
        { "try_stop_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStopScrollingAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayMarquee, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayMarquee), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayMarquee[] = {
        { "scroll_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_ScrollWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_ScrollWaitInterval), nullptr, nullptr },
        { "repeat_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_RepeatWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_RepeatWaitInterval), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(LineDisplayMarquee_get_Format), reinterpret_cast<setter>(LineDisplayMarquee_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayMarquee[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayMarquee) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayMarquee) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayMarquee) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayMarquee) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayMarquee =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayMarquee",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayMarquee
    };

    // ----- LineDisplayStatisticsCategorySelector class --------------------
    static constexpr const char* const type_name_LineDisplayStatisticsCategorySelector = "LineDisplayStatisticsCategorySelector";

    static PyObject* _new_LineDisplayStatisticsCategorySelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayStatisticsCategorySelector);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatisticsCategorySelector(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_AllStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"AllStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"ManufacturerStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ManufacturerStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"UnifiedPosStatistics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnifiedPosStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatisticsCategorySelector[] = {
        { "_assign_array_", _assign_array_LineDisplayStatisticsCategorySelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatisticsCategorySelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatisticsCategorySelector[] = {
        { "all_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_AllStatistics), nullptr, nullptr, nullptr },
        { "manufacturer_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics), nullptr, nullptr, nullptr },
        { "unified_pos_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatisticsCategorySelector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStatisticsCategorySelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStatisticsCategorySelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStatisticsCategorySelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStatisticsCategorySelector) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayStatisticsCategorySelector =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStatisticsCategorySelector",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatisticsCategorySelector
    };

    // ----- LineDisplayStatusUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_LineDisplayStatusUpdatedEventArgs = "LineDisplayStatusUpdatedEventArgs";

    static PyObject* _new_LineDisplayStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatusUpdatedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_LineDisplayStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(LineDisplayStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStatusUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatusUpdatedEventArgs
    };

    // ----- LineDisplayStoredBitmap class --------------------
    static constexpr const char* const type_name_LineDisplayStoredBitmap = "LineDisplayStoredBitmap";

    static PyObject* _new_LineDisplayStoredBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayStoredBitmap);
        return nullptr;
    }

    static void _dealloc_LineDisplayStoredBitmap(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStoredBitmap_TryDeleteAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayStoredBitmap", L"TryDeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayStoredBitmap_get_EscapeSequence(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStoredBitmap", L"EscapeSequence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EscapeSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStoredBitmap[] = {
        { "try_delete_async", reinterpret_cast<PyCFunction>(LineDisplayStoredBitmap_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayStoredBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStoredBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStoredBitmap[] = {
        { "escape_sequence", reinterpret_cast<getter>(LineDisplayStoredBitmap_get_EscapeSequence), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStoredBitmap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStoredBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStoredBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStoredBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStoredBitmap) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayStoredBitmap =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStoredBitmap",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStoredBitmap
    };

    // ----- LineDisplayWindow class --------------------
    static constexpr const char* const type_name_LineDisplayWindow = "LineDisplayWindow";

    static PyObject* _new_LineDisplayWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LineDisplayWindow);
        return nullptr;
    }

    static void _dealloc_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayWindow_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_ReadCharacterAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"ReadCharacterAtCursorAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadCharacterAtCursorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryClearTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryClearTextAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryClearTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtPointAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtPointAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStoredBitmapAtCursorAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>(args, 0);

                return py::convert(self->obj.TryDisplayStoredBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDisplayTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryRefreshAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryRefreshAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryRefreshAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryScrollTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryScrollTextAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.TryScrollTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"InterCharacterWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterCharacterWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayWindow_put_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"InterCharacterWaitInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InterCharacterWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayWindow_get_SizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"SizeInCharacters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Cursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Cursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Marquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Marquee"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Marquee());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayWindow[] = {
        { "close", reinterpret_cast<PyCFunction>(LineDisplayWindow_Close), METH_VARARGS, nullptr },
        { "read_character_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_ReadCharacterAtCursorAsync), METH_VARARGS, nullptr },
        { "try_clear_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryClearTextAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_point_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync), METH_VARARGS, nullptr },
        { "try_display_stored_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayTextAsync), METH_VARARGS, nullptr },
        { "try_refresh_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryRefreshAsync), METH_VARARGS, nullptr },
        { "try_scroll_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryScrollTextAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayWindow), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplayWindow), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LineDisplayWindow), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayWindow[] = {
        { "inter_character_wait_interval", reinterpret_cast<getter>(LineDisplayWindow_get_InterCharacterWaitInterval), reinterpret_cast<setter>(LineDisplayWindow_put_InterCharacterWaitInterval), nullptr, nullptr },
        { "size_in_characters", reinterpret_cast<getter>(LineDisplayWindow_get_SizeInCharacters), nullptr, nullptr, nullptr },
        { "cursor", reinterpret_cast<getter>(LineDisplayWindow_get_Cursor), nullptr, nullptr, nullptr },
        { "marquee", reinterpret_cast<getter>(LineDisplayWindow_get_Marquee), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayWindow) },
        { },
    };

    static PyType_Spec type_spec_LineDisplayWindow =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayWindow",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayWindow
    };

    // ----- MagneticStripeReader class --------------------
    static constexpr const char* const type_name_MagneticStripeReader = "MagneticStripeReader";

    static PyObject* _new_MagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReader_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"CheckHealthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_ClaimReaderAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"ClaimReaderAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClaimReaderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetErrorReportingType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetErrorReportingType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"RetrieveStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceAuthenticationProtocol(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"DeviceAuthenticationProtocol"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAuthenticationProtocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_SupportedCardTypes(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"SupportedCardTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCardTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::MagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReader[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_reader_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_ClaimReaderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_error_reporting_type", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetErrorReportingType), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReader[] = {
        { "capabilities", reinterpret_cast<getter>(MagneticStripeReader_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_authentication_protocol", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceAuthenticationProtocol), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "supported_card_types", reinterpret_cast<getter>(MagneticStripeReader_get_SupportedCardTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReader) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReader =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReader
    };

    // ----- MagneticStripeReaderAamvaCardDataReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs = "MagneticStripeReaderAamvaCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"BirthDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BirthDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Class"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Endorsements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Endorsements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"EyeColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EyeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"FirstName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Gender"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"HairColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HairColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"LicenseNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LicenseNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Report"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Restrictions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Restrictions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Suffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Surname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Weight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderAamvaCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderAamvaCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "address", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "birth_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate), nullptr, nullptr, nullptr },
        { "city", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City), nullptr, nullptr, nullptr },
        { "class_", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class), nullptr, nullptr, nullptr },
        { "endorsements", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "eye_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "gender", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender), nullptr, nullptr, nullptr },
        { "hair_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height), nullptr, nullptr, nullptr },
        { "license_number", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "restrictions", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderBankCardDataReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderBankCardDataReceivedEventArgs = "MagneticStripeReaderBankCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderBankCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderBankCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"AccountNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"FirstName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"MiddleInitial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MiddleInitial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Report"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"ServiceCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Suffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Surname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderBankCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderBankCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "account_number", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "middle_initial", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "service_code", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderCapabilities class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderCapabilities = "MagneticStripeReaderCapabilities";

    static PyObject* _new_MagneticStripeReaderCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderCapabilities);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderCapabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderCapabilities_get_AuthenticationLevel(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"AuthenticationLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_CardAuthentication(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"CardAuthentication"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardAuthentication());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsIsoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsIsoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIsoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisOneSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsJisOneSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsJisOneSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisTwoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsJisTwoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsJisTwoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsStatisticsReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsStatisticsUpdatingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsTrackDataMaskingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrackDataMaskingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsTransmitSentinelsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmitSentinelsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"PowerReportingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"SupportedEncryptionAlgorithms"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedEncryptionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCapabilities[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCapabilities[] = {
        { "authentication_level", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_AuthenticationLevel), nullptr, nullptr, nullptr },
        { "card_authentication", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_CardAuthentication), nullptr, nullptr, nullptr },
        { "is_iso_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsIsoSupported), nullptr, nullptr, nullptr },
        { "is_jis_one_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisOneSupported), nullptr, nullptr, nullptr },
        { "is_jis_two_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisTwoSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_track_data_masking_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported), nullptr, nullptr, nullptr },
        { "is_transmit_sentinels_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_encryption_algorithms", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderCapabilities) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCapabilities
    };

    // ----- MagneticStripeReaderCardTypes class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderCardTypes = "MagneticStripeReaderCardTypes";

    static PyObject* _new_MagneticStripeReaderCardTypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderCardTypes);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Aamva(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Aamva"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Aamva());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Bank(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Bank"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Bank());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"ExtendedBase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Unknown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCardTypes[] = {
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCardTypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCardTypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderCardTypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderCardTypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderCardTypes) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderCardTypes =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderCardTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCardTypes
    };

    static PyGetSetDef getset_MagneticStripeReaderCardTypes_Meta[] = {
        { "aamva", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Aamva), nullptr, nullptr, nullptr },
        { "bank", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Bank), nullptr, nullptr, nullptr },
        { "extended_base", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "unknown", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Unknown), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MagneticStripeReaderCardTypes_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MagneticStripeReaderCardTypes_Meta) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderCardTypes_Meta =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderCardTypes_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MagneticStripeReaderCardTypes_Meta
    };

    // ----- MagneticStripeReaderEncryptionAlgorithms class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderEncryptionAlgorithms = "MagneticStripeReaderEncryptionAlgorithms";

    static PyObject* _new_MagneticStripeReaderEncryptionAlgorithms(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderEncryptionAlgorithms);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"ExtendedBase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_None(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"None"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::None());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"TripleDesDukpt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::TripleDesDukpt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderEncryptionAlgorithms[] = {
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderEncryptionAlgorithms[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderEncryptionAlgorithms[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderEncryptionAlgorithms) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderEncryptionAlgorithms) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderEncryptionAlgorithms) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderEncryptionAlgorithms =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderEncryptionAlgorithms",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderEncryptionAlgorithms
    };

    static PyGetSetDef getset_MagneticStripeReaderEncryptionAlgorithms_Meta[] = {
        { "extended_base", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "none", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_None), nullptr, nullptr, nullptr },
        { "triple_des_dukpt", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MagneticStripeReaderEncryptionAlgorithms_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MagneticStripeReaderEncryptionAlgorithms_Meta) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderEncryptionAlgorithms_Meta =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderEncryptionAlgorithms_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MagneticStripeReaderEncryptionAlgorithms_Meta
    };

    // ----- MagneticStripeReaderErrorOccurredEventArgs class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderErrorOccurredEventArgs = "MagneticStripeReaderErrorOccurredEventArgs";

    static PyObject* _new_MagneticStripeReaderErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"ErrorData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"PartialInputData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track1Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track1Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track2Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track2Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track3Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track3Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track4Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track4Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { "track1_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status), nullptr, nullptr, nullptr },
        { "track2_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status), nullptr, nullptr, nullptr },
        { "track3_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status), nullptr, nullptr, nullptr },
        { "track4_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderErrorOccurredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderErrorOccurredEventArgs
    };

    // ----- MagneticStripeReaderReport class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderReport = "MagneticStripeReaderReport";

    static PyObject* _new_MagneticStripeReaderReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderReport);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderReport(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderReport_get_AdditionalSecurityInformation(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"AdditionalSecurityInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalSecurityInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardAuthenticationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardAuthenticationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationDataLength(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardAuthenticationDataLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardAuthenticationDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CardType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Properties(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track1(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track2(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track3(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track4(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderReport[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderReport[] = {
        { "additional_security_information", reinterpret_cast<getter>(MagneticStripeReaderReport_get_AdditionalSecurityInformation), nullptr, nullptr, nullptr },
        { "card_authentication_data", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationData), nullptr, nullptr, nullptr },
        { "card_authentication_data_length", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationDataLength), nullptr, nullptr, nullptr },
        { "card_type", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardType), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Properties), nullptr, nullptr, nullptr },
        { "track1", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track1), nullptr, nullptr, nullptr },
        { "track2", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track2), nullptr, nullptr, nullptr },
        { "track3", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track3), nullptr, nullptr, nullptr },
        { "track4", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track4), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderReport) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderReport =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderReport
    };

    // ----- MagneticStripeReaderStatusUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderStatusUpdatedEventArgs = "MagneticStripeReaderStatusUpdatedEventArgs";

    static PyObject* _new_MagneticStripeReaderStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs", L"ExtendedStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderStatusUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderStatusUpdatedEventArgs
    };

    // ----- MagneticStripeReaderTrackData class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderTrackData = "MagneticStripeReaderTrackData";

    static PyObject* _new_MagneticStripeReaderTrackData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderTrackData);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderTrackData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderTrackData_get_Data(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_DiscretionaryData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"DiscretionaryData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DiscretionaryData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_EncryptedData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"EncryptedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderTrackData[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderTrackData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderTrackData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderTrackData[] = {
        { "data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_Data), nullptr, nullptr, nullptr },
        { "discretionary_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_DiscretionaryData), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderTrackData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderTrackData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderTrackData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderTrackData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderTrackData) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderTrackData =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderTrackData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderTrackData
    };

    // ----- MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = "MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs", L"Report"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs
    };

    // ----- PosPrinter class --------------------
    static constexpr const char* const type_name_PosPrinter = "PosPrinter";

    static PyObject* _new_PosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinter);
        return nullptr;
    }

    static void _dealloc_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinter_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"CheckHealthAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_ClaimPrinterAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"ClaimPrinterAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClaimPrinterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDefaultAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetFontProperty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFontProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetStatisticsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedCharacterSets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedTypeFaces(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedTypeFaces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedTypeFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedBarcodeSymbologies(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedBarcodeSymbologies"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBarcodeSymbologies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.PosPrinter", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::PosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.PosPrinter", L"StatusUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinter[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(PosPrinter_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_printer_async", reinterpret_cast<PyCFunction>(PosPrinter_ClaimPrinterAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(PosPrinter_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PosPrinter_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(PosPrinter_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PosPrinter_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_font_property", reinterpret_cast<PyCFunction>(PosPrinter_GetFontProperty), METH_VARARGS, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(PosPrinter_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_PosPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PosPrinter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinter[] = {
        { "capabilities", reinterpret_cast<getter>(PosPrinter_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PosPrinter_get_Status), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(PosPrinter_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_type_faces", reinterpret_cast<getter>(PosPrinter_get_SupportedTypeFaces), nullptr, nullptr, nullptr },
        { "supported_barcode_symbologies", reinterpret_cast<getter>(PosPrinter_get_SupportedBarcodeSymbologies), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinter) },
        { },
    };

    static PyType_Spec type_spec_PosPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinter
    };

    // ----- PosPrinterCapabilities class --------------------
    static constexpr const char* const type_name_PosPrinterCapabilities = "PosPrinterCapabilities";

    static PyObject* _new_PosPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_PosPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterCapabilities_get_CanMapCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"CanMapCharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMapCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_DefaultCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"DefaultCharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_HasCoverSensor(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"HasCoverSensor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCoverSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsStatisticsReportingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsStatisticsUpdatingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsTransactionSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsTransactionSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransactionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Journal(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Journal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"PowerReportingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Receipt(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Receipt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Slip(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Slip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_PosPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterCapabilities[] = {
        { "can_map_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_CanMapCharacterSet), nullptr, nullptr, nullptr },
        { "default_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_DefaultCharacterSet), nullptr, nullptr, nullptr },
        { "has_cover_sensor", reinterpret_cast<getter>(PosPrinterCapabilities_get_HasCoverSensor), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_transaction_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsTransactionSupported), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(PosPrinterCapabilities_get_Journal), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(PosPrinterCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(PosPrinterCapabilities_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(PosPrinterCapabilities_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterCapabilities) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCapabilities
    };

    // ----- PosPrinterCharacterSetIds class --------------------
    static constexpr const char* const type_name_PosPrinterCharacterSetIds = "PosPrinterCharacterSetIds";

    static PyObject* _new_PosPrinterCharacterSetIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterCharacterSetIds);
        return nullptr;
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ansi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Ansi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ansi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ascii(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Ascii"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ascii());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Utf16LE(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Utf16LE"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Utf16LE());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCharacterSetIds[] = {
        { }
    };

    static PyGetSetDef _getset_PosPrinterCharacterSetIds[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCharacterSetIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterCharacterSetIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterCharacterSetIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterCharacterSetIds) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterCharacterSetIds =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterCharacterSetIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCharacterSetIds
    };

    static PyGetSetDef getset_PosPrinterCharacterSetIds_Meta[] = {
        { "ansi", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Ansi), nullptr, nullptr, nullptr },
        { "ascii", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Ascii), nullptr, nullptr, nullptr },
        { "utf16_l_e", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Utf16LE), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PosPrinterCharacterSetIds_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PosPrinterCharacterSetIds_Meta) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterCharacterSetIds_Meta =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterCharacterSetIds_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PosPrinterCharacterSetIds_Meta
    };

    // ----- PosPrinterFontProperty class --------------------
    static constexpr const char* const type_name_PosPrinterFontProperty = "PosPrinterFontProperty";

    static PyObject* _new_PosPrinterFontProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterFontProperty);
        return nullptr;
    }

    static void _dealloc_PosPrinterFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterFontProperty_get_CharacterSizes(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"CharacterSizes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterSizes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_IsScalableToAnySize(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"IsScalableToAnySize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScalableToAnySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"TypeFace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterFontProperty[] = {
        { "_assign_array_", _assign_array_PosPrinterFontProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterFontProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterFontProperty[] = {
        { "character_sizes", reinterpret_cast<getter>(PosPrinterFontProperty_get_CharacterSizes), nullptr, nullptr, nullptr },
        { "is_scalable_to_any_size", reinterpret_cast<getter>(PosPrinterFontProperty_get_IsScalableToAnySize), nullptr, nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterFontProperty_get_TypeFace), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterFontProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterFontProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterFontProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterFontProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterFontProperty) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterFontProperty =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterFontProperty",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterFontProperty
    };

    // ----- PosPrinterPrintOptions class --------------------
    static constexpr const char* const type_name_PosPrinterPrintOptions = "PosPrinterPrintOptions";

    static PyObject* _new_PosPrinterPrintOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PosPrinterPrintOptions(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterPrintOptions_get_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Underline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Underline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"TypeFace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"TypeFace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TypeFace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Superscript"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Superscript"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Subscript"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Subscript"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Strikethrough"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Strikethrough"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"ReverseVideo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReverseVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"ReverseVideo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ReverseVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Italic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Italic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleWide"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DoubleWide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleWide"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleWide(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DoubleHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterSet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Bold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Bold"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Alignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Alignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterPrintOptions[] = {
        { "_assign_array_", _assign_array_PosPrinterPrintOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterPrintOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterPrintOptions[] = {
        { "underline", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Underline), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Underline), nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterPrintOptions_get_TypeFace), reinterpret_cast<setter>(PosPrinterPrintOptions_put_TypeFace), nullptr, nullptr },
        { "superscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Superscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Superscript), nullptr, nullptr },
        { "subscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Subscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Subscript), nullptr, nullptr },
        { "strikethrough", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Strikethrough), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Strikethrough), nullptr, nullptr },
        { "reverse_video", reinterpret_cast<getter>(PosPrinterPrintOptions_get_ReverseVideo), reinterpret_cast<setter>(PosPrinterPrintOptions_put_ReverseVideo), nullptr, nullptr },
        { "italic", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Italic), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Italic), nullptr, nullptr },
        { "double_wide", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleWide), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleWide), nullptr, nullptr },
        { "double_high", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleHigh), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleHigh), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterSet), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterSet), nullptr, nullptr },
        { "character_height", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterHeight), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterHeight), nullptr, nullptr },
        { "bold", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Bold), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Bold), nullptr, nullptr },
        { "alignment", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Alignment), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Alignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterPrintOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterPrintOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterPrintOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterPrintOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterPrintOptions) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterPrintOptions =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterPrintOptions",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterPrintOptions
    };

    // ----- PosPrinterReleaseDeviceRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PosPrinterReleaseDeviceRequestedEventArgs = "PosPrinterReleaseDeviceRequestedEventArgs";

    static PyObject* _new_PosPrinterReleaseDeviceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterReleaseDeviceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterReleaseDeviceRequestedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_PosPrinterReleaseDeviceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterReleaseDeviceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterReleaseDeviceRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterReleaseDeviceRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterReleaseDeviceRequestedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterReleaseDeviceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterReleaseDeviceRequestedEventArgs
    };

    // ----- PosPrinterStatus class --------------------
    static constexpr const char* const type_name_PosPrinterStatus = "PosPrinterStatus";

    static PyObject* _new_PosPrinterStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterStatus);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatus", L"ExtendedStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatus", L"StatusKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatus[] = {
        { "_assign_array_", _assign_array_PosPrinterStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatus[] = {
        { "extended_status", reinterpret_cast<getter>(PosPrinterStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(PosPrinterStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterStatus) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterStatus =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatus
    };

    // ----- PosPrinterStatusUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_PosPrinterStatusUpdatedEventArgs = "PosPrinterStatusUpdatedEventArgs";

    static PyObject* _new_PosPrinterStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PosPrinterStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_PosPrinterStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(PosPrinterStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterStatusUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PosPrinterStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatusUpdatedEventArgs
    };

    // ----- ReceiptPrintJob class --------------------
    static constexpr const char* const type_name_ReceiptPrintJob = "ReceiptPrintJob";

    static PyObject* _new_ReceiptPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ReceiptPrintJob);
        return nullptr;
    }

    static void _dealloc_ReceiptPrintJob(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReceiptPrintJob_CutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"CutPaper", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CutPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"CutPaper", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.CutPaper(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"DrawRuledLine", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"ExecuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"FeedPaperByLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"FeedPaperByMapModeUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_MarkFeed(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"MarkFeed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind>(args, 0);

                self->obj.MarkFeed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"Print", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"Print", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBarcode", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBarcodeCustomAlign", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintCustomAlignedBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintLine", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintSavedBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBarcodeRotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetCustomAlignedBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetPrintArea", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetPrintRotation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_StampPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"StampPaper", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StampPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrintJob[] = {
        { "cut_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_CutPaper), METH_VARARGS, nullptr },
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(ReceiptPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "mark_feed", reinterpret_cast<PyCFunction>(ReceiptPrintJob_MarkFeed), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(ReceiptPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "stamp_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_StampPaper), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ReceiptPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrintJob[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReceiptPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReceiptPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReceiptPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReceiptPrintJob) },
        { },
    };

    static PyType_Spec type_spec_ReceiptPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.ReceiptPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrintJob
    };

    // ----- ReceiptPrinterCapabilities class --------------------
    static constexpr const char* const type_name_ReceiptPrinterCapabilities = "ReceiptPrinterCapabilities";

    static PyObject* _new_ReceiptPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ReceiptPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_ReceiptPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReceiptPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"CartridgeSensors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"ColorCartridgeCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleHighPrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDualColorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsItalicSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPaperEmptySensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPrinterPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedCharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"Is180RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBarcodeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBitmapSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsLeft90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPrintAreaSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsRight90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"RuledLineCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedBarcodeRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedBitmapRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_CanCutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"CanCutPaper"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanCutPaper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStampSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsStampSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStampSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_MarkFeedCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"MarkFeedCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MarkFeedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReverseVideoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsStrikethroughSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsSubscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsSuperscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_ReceiptPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "can_cut_paper", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CanCutPaper), nullptr, nullptr, nullptr },
        { "is_stamp_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStampSupported), nullptr, nullptr, nullptr },
        { "mark_feed_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_MarkFeedCapabilities), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrinterCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReceiptPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReceiptPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReceiptPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReceiptPrinterCapabilities) },
        { },
    };

    static PyType_Spec type_spec_ReceiptPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ReceiptPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrinterCapabilities
    };

    // ----- SlipPrintJob class --------------------
    static constexpr const char* const type_name_SlipPrintJob = "SlipPrintJob";

    static PyObject* _new_SlipPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SlipPrintJob);
        return nullptr;
    }

    static void _dealloc_SlipPrintJob(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlipPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"DrawRuledLine", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"ExecuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"FeedPaperByLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"FeedPaperByMapModeUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"Print", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"Print", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBarcode", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBarcodeCustomAlign", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintCustomAlignedBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintLine", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintSavedBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBarcodeRotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetCustomAlignedBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetPrintArea", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetPrintRotation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::SlipPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrintJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(SlipPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(SlipPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(SlipPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SlipPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_SlipPrintJob[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlipPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlipPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlipPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlipPrintJob) },
        { },
    };

    static PyType_Spec type_spec_SlipPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.SlipPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrintJob
    };

    // ----- SlipPrinterCapabilities class --------------------
    static constexpr const char* const type_name_SlipPrinterCapabilities = "SlipPrinterCapabilities";

    static PyObject* _new_SlipPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SlipPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_SlipPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlipPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"CartridgeSensors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"ColorCartridgeCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleHighPrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDualColorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsItalicSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPaperEmptySensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPrinterPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedCharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"Is180RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBarcodeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBitmapSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsLeft90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPrintAreaSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsRight90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"RuledLineCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedBarcodeRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedBitmapRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBothSidesPrintingSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBothSidesPrintingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBothSidesPrintingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsFullLengthSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsFullLengthSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFullLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReverseVideoSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsStrikethroughSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsSubscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsSuperscriptSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_SlipPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(SlipPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "is_both_sides_printing_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBothSidesPrintingSupported), nullptr, nullptr, nullptr },
        { "is_full_length_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsFullLengthSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlipPrinterCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlipPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlipPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlipPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlipPrinterCapabilities) },
        { },
    };

    static PyType_Spec type_spec_SlipPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.SlipPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrinterCapabilities
    };

    // ----- UnifiedPosErrorData class --------------------
    static constexpr const char* const type_name_UnifiedPosErrorData = "UnifiedPosErrorData";

    static PyObject* _new_UnifiedPosErrorData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::PointOfService::UnifiedPosErrorData instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UnifiedPosErrorData(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnifiedPosErrorData_get_ExtendedReason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"ExtendedReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Message(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Reason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Severity(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Severity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Severity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnifiedPosErrorData[] = {
        { "_assign_array_", _assign_array_UnifiedPosErrorData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnifiedPosErrorData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnifiedPosErrorData[] = {
        { "extended_reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_ExtendedReason), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(UnifiedPosErrorData_get_Message), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_Reason), nullptr, nullptr, nullptr },
        { "severity", reinterpret_cast<getter>(UnifiedPosErrorData_get_Severity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnifiedPosErrorData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnifiedPosErrorData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnifiedPosErrorData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnifiedPosErrorData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnifiedPosErrorData) },
        { },
    };

    static PyType_Spec type_spec_UnifiedPosErrorData =
    {
        "_winsdk_Windows_Devices_PointOfService.UnifiedPosErrorData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnifiedPosErrorData
    };

    // ----- ICashDrawerEventSourceEventArgs interface --------------------
    static constexpr const char* const type_name_ICashDrawerEventSourceEventArgs = "ICashDrawerEventSourceEventArgs";

    static PyObject* _new_ICashDrawerEventSourceEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICashDrawerEventSourceEventArgs);
        return nullptr;
    }

    static void _dealloc_ICashDrawerEventSourceEventArgs(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICashDrawerEventSourceEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICashDrawerEventSourceEventArgs", L"CashDrawer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICashDrawerEventSourceEventArgs[] = {
        { "_assign_array_", _assign_array_ICashDrawerEventSourceEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICashDrawerEventSourceEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICashDrawerEventSourceEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(ICashDrawerEventSourceEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICashDrawerEventSourceEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICashDrawerEventSourceEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICashDrawerEventSourceEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICashDrawerEventSourceEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICashDrawerEventSourceEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ICashDrawerEventSourceEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ICashDrawerEventSourceEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICashDrawerEventSourceEventArgs
    };

    // ----- ICommonClaimedPosPrinterStation interface --------------------
    static constexpr const char* const type_name_ICommonClaimedPosPrinterStation = "ICommonClaimedPosPrinterStation";

    static PyObject* _new_ICommonClaimedPosPrinterStation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICommonClaimedPosPrinterStation);
        return nullptr;
    }

    static void _dealloc_ICommonClaimedPosPrinterStation(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonClaimedPosPrinterStation_ValidateData(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ValidateData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"CharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ColorCartridge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCartridgeEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCartridgeRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCoverOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsHeadCleaning"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsLetterQuality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsPaperEmpty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsPaperNearEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsReadyToPrint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonClaimedPosPrinterStation[] = {
        { "validate_data", reinterpret_cast<PyCFunction>(ICommonClaimedPosPrinterStation_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICommonClaimedPosPrinterStation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonClaimedPosPrinterStation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonClaimedPosPrinterStation[] = {
        { "characters_per_line", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_CharactersPerLine), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_CharactersPerLine), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_ColorCartridge), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_ColorCartridge), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsLetterQuality), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_IsLetterQuality), nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineHeight), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineHeight), nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineSpacing), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineSpacing), nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonClaimedPosPrinterStation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonClaimedPosPrinterStation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonClaimedPosPrinterStation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonClaimedPosPrinterStation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonClaimedPosPrinterStation) },
        { },
    };

    static PyType_Spec type_spec_ICommonClaimedPosPrinterStation =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonClaimedPosPrinterStation",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonClaimedPosPrinterStation
    };

    // ----- ICommonPosPrintStationCapabilities interface --------------------
    static constexpr const char* const type_name_ICommonPosPrintStationCapabilities = "ICommonPosPrintStationCapabilities";

    static PyObject* _new_ICommonPosPrintStationCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICommonPosPrintStationCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonPosPrintStationCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"CartridgeSensors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"ColorCartridgeCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsBoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighPrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDualColorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsItalicSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperEmptySensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperNearEndSensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPrinterPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"SupportedCharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonPosPrintStationCapabilities[] = {
        { "_assign_array_", _assign_array_ICommonPosPrintStationCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonPosPrintStationCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonPosPrintStationCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonPosPrintStationCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonPosPrintStationCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonPosPrintStationCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonPosPrintStationCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonPosPrintStationCapabilities) },
        { },
    };

    static PyType_Spec type_spec_ICommonPosPrintStationCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonPosPrintStationCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonPosPrintStationCapabilities
    };

    // ----- ICommonReceiptSlipCapabilities interface --------------------
    static constexpr const char* const type_name_ICommonReceiptSlipCapabilities = "ICommonReceiptSlipCapabilities";

    static PyObject* _new_ICommonReceiptSlipCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICommonReceiptSlipCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonReceiptSlipCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"Is180RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsBarcodeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsBitmapSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsLeft90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsPrintAreaSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsRight90RotationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"RuledLineCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"SupportedBarcodeRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"SupportedBitmapRotations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"CartridgeSensors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"ColorCartridgeCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsBoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighPrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleWidePrintSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDualColorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsItalicSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperEmptySensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperNearEndSensorSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPrinterPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsUnderlineSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"SupportedCharactersPerLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonReceiptSlipCapabilities[] = {
        { "_assign_array_", _assign_array_ICommonReceiptSlipCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonReceiptSlipCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonReceiptSlipCapabilities[] = {
        { "is180_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonReceiptSlipCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonReceiptSlipCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonReceiptSlipCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonReceiptSlipCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonReceiptSlipCapabilities) },
        { },
    };

    static PyType_Spec type_spec_ICommonReceiptSlipCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonReceiptSlipCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonReceiptSlipCapabilities
    };

    // ----- IPosPrinterJob interface --------------------
    static constexpr const char* const type_name_IPosPrinterJob = "IPosPrinterJob";

    static PyObject* _new_IPosPrinterJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IPosPrinterJob);
        return nullptr;
    }

    static void _dealloc_IPosPrinterJob(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPosPrinterJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"ExecuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_Print(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"Print", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::IPosPrinterJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IPosPrinterJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPosPrinterJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(IPosPrinterJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IPosPrinterJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IPosPrinterJob_PrintLine), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPosPrinterJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPosPrinterJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPosPrinterJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IPosPrinterJob[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPosPrinterJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPosPrinterJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPosPrinterJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPosPrinterJob) },
        { },
    };

    static PyType_Spec type_spec_IPosPrinterJob =
    {
        "_winsdk_Windows_Devices_PointOfService.IPosPrinterJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPosPrinterJob
    };

    // ----- IReceiptOrSlipJob interface --------------------
    static constexpr const char* const type_name_IReceiptOrSlipJob = "IReceiptOrSlipJob";

    static PyObject* _new_IReceiptOrSlipJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IReceiptOrSlipJob);
        return nullptr;
    }

    static void _dealloc_IReceiptOrSlipJob(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReceiptOrSlipJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"DrawRuledLine", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"ExecuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_Print(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"Print", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBarcode", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBarcodeCustomAlign", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintCustomAlignedBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintSavedBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBarcodeRotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetCustomAlignedBitmap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetCustomAlignedBitmap", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetPrintArea", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetPrintRotation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReceiptOrSlipJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IReceiptOrSlipJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IReceiptOrSlipJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IReceiptOrSlipJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IReceiptOrSlipJob[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReceiptOrSlipJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReceiptOrSlipJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReceiptOrSlipJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReceiptOrSlipJob) },
        { },
    };

    static PyType_Spec type_spec_IReceiptOrSlipJob =
    {
        "_winsdk_Windows_Devices_PointOfService.IReceiptOrSlipJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReceiptOrSlipJob
    };

    // ----- SizeUInt32 struct --------------------
    static constexpr const char* const type_name_SizeUInt32 = "SizeUInt32";

    PyObject* _new_SizeUInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SizeUInt32(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self) noexcept
    {
    }

    static PyObject* SizeUInt32_get_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SizeUInt32_get_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SizeUInt32[] = {
        { "width", reinterpret_cast<getter>(SizeUInt32_get_Width), reinterpret_cast<setter>(SizeUInt32_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(SizeUInt32_get_Height), reinterpret_cast<setter>(SizeUInt32_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SizeUInt32[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SizeUInt32) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SizeUInt32) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SizeUInt32) },
        { },
    };

    static PyType_Spec type_spec_SizeUInt32 =
    {
        "_winsdk_Windows_Devices_PointOfService.SizeUInt32",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SizeUInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeUInt32
    };

    // ----- Windows.Devices.PointOfService Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::PointOfService");

    static PyMethodDef module_methods[] = {
        {"_register_BarcodeScannerStatus", register_BarcodeScannerStatus, METH_O, "registers type"},
        {"_register_BarcodeSymbologyDecodeLengthKind", register_BarcodeSymbologyDecodeLengthKind, METH_O, "registers type"},
        {"_register_CashDrawerStatusKind", register_CashDrawerStatusKind, METH_O, "registers type"},
        {"_register_LineDisplayCursorType", register_LineDisplayCursorType, METH_O, "registers type"},
        {"_register_LineDisplayDescriptorState", register_LineDisplayDescriptorState, METH_O, "registers type"},
        {"_register_LineDisplayHorizontalAlignment", register_LineDisplayHorizontalAlignment, METH_O, "registers type"},
        {"_register_LineDisplayMarqueeFormat", register_LineDisplayMarqueeFormat, METH_O, "registers type"},
        {"_register_LineDisplayPowerStatus", register_LineDisplayPowerStatus, METH_O, "registers type"},
        {"_register_LineDisplayScrollDirection", register_LineDisplayScrollDirection, METH_O, "registers type"},
        {"_register_LineDisplayTextAttribute", register_LineDisplayTextAttribute, METH_O, "registers type"},
        {"_register_LineDisplayTextAttributeGranularity", register_LineDisplayTextAttributeGranularity, METH_O, "registers type"},
        {"_register_LineDisplayVerticalAlignment", register_LineDisplayVerticalAlignment, METH_O, "registers type"},
        {"_register_MagneticStripeReaderAuthenticationLevel", register_MagneticStripeReaderAuthenticationLevel, METH_O, "registers type"},
        {"_register_MagneticStripeReaderAuthenticationProtocol", register_MagneticStripeReaderAuthenticationProtocol, METH_O, "registers type"},
        {"_register_MagneticStripeReaderErrorReportingType", register_MagneticStripeReaderErrorReportingType, METH_O, "registers type"},
        {"_register_MagneticStripeReaderStatus", register_MagneticStripeReaderStatus, METH_O, "registers type"},
        {"_register_MagneticStripeReaderTrackErrorType", register_MagneticStripeReaderTrackErrorType, METH_O, "registers type"},
        {"_register_MagneticStripeReaderTrackIds", register_MagneticStripeReaderTrackIds, METH_O, "registers type"},
        {"_register_PosConnectionTypes", register_PosConnectionTypes, METH_O, "registers type"},
        {"_register_PosPrinterAlignment", register_PosPrinterAlignment, METH_O, "registers type"},
        {"_register_PosPrinterBarcodeTextPosition", register_PosPrinterBarcodeTextPosition, METH_O, "registers type"},
        {"_register_PosPrinterCartridgeSensors", register_PosPrinterCartridgeSensors, METH_O, "registers type"},
        {"_register_PosPrinterColorCapabilities", register_PosPrinterColorCapabilities, METH_O, "registers type"},
        {"_register_PosPrinterColorCartridge", register_PosPrinterColorCartridge, METH_O, "registers type"},
        {"_register_PosPrinterLineDirection", register_PosPrinterLineDirection, METH_O, "registers type"},
        {"_register_PosPrinterLineStyle", register_PosPrinterLineStyle, METH_O, "registers type"},
        {"_register_PosPrinterMapMode", register_PosPrinterMapMode, METH_O, "registers type"},
        {"_register_PosPrinterMarkFeedCapabilities", register_PosPrinterMarkFeedCapabilities, METH_O, "registers type"},
        {"_register_PosPrinterMarkFeedKind", register_PosPrinterMarkFeedKind, METH_O, "registers type"},
        {"_register_PosPrinterPrintSide", register_PosPrinterPrintSide, METH_O, "registers type"},
        {"_register_PosPrinterRotation", register_PosPrinterRotation, METH_O, "registers type"},
        {"_register_PosPrinterRuledLineCapabilities", register_PosPrinterRuledLineCapabilities, METH_O, "registers type"},
        {"_register_PosPrinterStatusKind", register_PosPrinterStatusKind, METH_O, "registers type"},
        {"_register_UnifiedPosErrorReason", register_UnifiedPosErrorReason, METH_O, "registers type"},
        {"_register_UnifiedPosErrorSeverity", register_UnifiedPosErrorSeverity, METH_O, "registers type"},
        {"_register_UnifiedPosHealthCheckLevel", register_UnifiedPosHealthCheckLevel, METH_O, "registers type"},
        {"_register_UnifiedPosPowerReportingType", register_UnifiedPosPowerReportingType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_BarcodeScannerStatus);
        Py_VISIT(state->type_BarcodeSymbologyDecodeLengthKind);
        Py_VISIT(state->type_CashDrawerStatusKind);
        Py_VISIT(state->type_LineDisplayCursorType);
        Py_VISIT(state->type_LineDisplayDescriptorState);
        Py_VISIT(state->type_LineDisplayHorizontalAlignment);
        Py_VISIT(state->type_LineDisplayMarqueeFormat);
        Py_VISIT(state->type_LineDisplayPowerStatus);
        Py_VISIT(state->type_LineDisplayScrollDirection);
        Py_VISIT(state->type_LineDisplayTextAttribute);
        Py_VISIT(state->type_LineDisplayTextAttributeGranularity);
        Py_VISIT(state->type_LineDisplayVerticalAlignment);
        Py_VISIT(state->type_MagneticStripeReaderAuthenticationLevel);
        Py_VISIT(state->type_MagneticStripeReaderAuthenticationProtocol);
        Py_VISIT(state->type_MagneticStripeReaderErrorReportingType);
        Py_VISIT(state->type_MagneticStripeReaderStatus);
        Py_VISIT(state->type_MagneticStripeReaderTrackErrorType);
        Py_VISIT(state->type_MagneticStripeReaderTrackIds);
        Py_VISIT(state->type_PosConnectionTypes);
        Py_VISIT(state->type_PosPrinterAlignment);
        Py_VISIT(state->type_PosPrinterBarcodeTextPosition);
        Py_VISIT(state->type_PosPrinterCartridgeSensors);
        Py_VISIT(state->type_PosPrinterColorCapabilities);
        Py_VISIT(state->type_PosPrinterColorCartridge);
        Py_VISIT(state->type_PosPrinterLineDirection);
        Py_VISIT(state->type_PosPrinterLineStyle);
        Py_VISIT(state->type_PosPrinterMapMode);
        Py_VISIT(state->type_PosPrinterMarkFeedCapabilities);
        Py_VISIT(state->type_PosPrinterMarkFeedKind);
        Py_VISIT(state->type_PosPrinterPrintSide);
        Py_VISIT(state->type_PosPrinterRotation);
        Py_VISIT(state->type_PosPrinterRuledLineCapabilities);
        Py_VISIT(state->type_PosPrinterStatusKind);
        Py_VISIT(state->type_UnifiedPosErrorReason);
        Py_VISIT(state->type_UnifiedPosErrorSeverity);
        Py_VISIT(state->type_UnifiedPosHealthCheckLevel);
        Py_VISIT(state->type_UnifiedPosPowerReportingType);
        Py_VISIT(state->type_BarcodeScanner);
        Py_VISIT(state->type_BarcodeScannerCapabilities);
        Py_VISIT(state->type_BarcodeScannerDataReceivedEventArgs);
        Py_VISIT(state->type_BarcodeScannerErrorOccurredEventArgs);
        Py_VISIT(state->type_BarcodeScannerImagePreviewReceivedEventArgs);
        Py_VISIT(state->type_BarcodeScannerReport);
        Py_VISIT(state->type_BarcodeScannerStatusUpdatedEventArgs);
        Py_VISIT(state->type_BarcodeSymbologies);
        Py_VISIT(state->type_BarcodeSymbologyAttributes);
        Py_VISIT(state->type_CashDrawer);
        Py_VISIT(state->type_CashDrawerCapabilities);
        Py_VISIT(state->type_CashDrawerCloseAlarm);
        Py_VISIT(state->type_CashDrawerClosedEventArgs);
        Py_VISIT(state->type_CashDrawerEventSource);
        Py_VISIT(state->type_CashDrawerOpenedEventArgs);
        Py_VISIT(state->type_CashDrawerStatus);
        Py_VISIT(state->type_CashDrawerStatusUpdatedEventArgs);
        Py_VISIT(state->type_ClaimedBarcodeScanner);
        Py_VISIT(state->type_ClaimedBarcodeScannerClosedEventArgs);
        Py_VISIT(state->type_ClaimedCashDrawer);
        Py_VISIT(state->type_ClaimedCashDrawerClosedEventArgs);
        Py_VISIT(state->type_ClaimedJournalPrinter);
        Py_VISIT(state->type_ClaimedLineDisplay);
        Py_VISIT(state->type_ClaimedLineDisplayClosedEventArgs);
        Py_VISIT(state->type_ClaimedMagneticStripeReader);
        Py_VISIT(state->type_ClaimedMagneticStripeReaderClosedEventArgs);
        Py_VISIT(state->type_ClaimedPosPrinter);
        Py_VISIT(state->type_ClaimedPosPrinterClosedEventArgs);
        Py_VISIT(state->type_ClaimedReceiptPrinter);
        Py_VISIT(state->type_ClaimedSlipPrinter);
        Py_VISIT(state->type_JournalPrintJob);
        Py_VISIT(state->type_JournalPrinterCapabilities);
        Py_VISIT(state->type_LineDisplay);
        Py_VISIT(state->type_LineDisplayAttributes);
        Py_VISIT(state->type_LineDisplayCapabilities);
        Py_VISIT(state->type_LineDisplayCursor);
        Py_VISIT(state->type_LineDisplayCursorAttributes);
        Py_VISIT(state->type_LineDisplayCustomGlyphs);
        Py_VISIT(state->type_LineDisplayMarquee);
        Py_VISIT(state->type_LineDisplayStatisticsCategorySelector);
        Py_VISIT(state->type_LineDisplayStatusUpdatedEventArgs);
        Py_VISIT(state->type_LineDisplayStoredBitmap);
        Py_VISIT(state->type_LineDisplayWindow);
        Py_VISIT(state->type_MagneticStripeReader);
        Py_VISIT(state->type_MagneticStripeReaderAamvaCardDataReceivedEventArgs);
        Py_VISIT(state->type_MagneticStripeReaderBankCardDataReceivedEventArgs);
        Py_VISIT(state->type_MagneticStripeReaderCapabilities);
        Py_VISIT(state->type_MagneticStripeReaderCardTypes);
        Py_VISIT(state->type_MagneticStripeReaderEncryptionAlgorithms);
        Py_VISIT(state->type_MagneticStripeReaderErrorOccurredEventArgs);
        Py_VISIT(state->type_MagneticStripeReaderReport);
        Py_VISIT(state->type_MagneticStripeReaderStatusUpdatedEventArgs);
        Py_VISIT(state->type_MagneticStripeReaderTrackData);
        Py_VISIT(state->type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs);
        Py_VISIT(state->type_PosPrinter);
        Py_VISIT(state->type_PosPrinterCapabilities);
        Py_VISIT(state->type_PosPrinterCharacterSetIds);
        Py_VISIT(state->type_PosPrinterFontProperty);
        Py_VISIT(state->type_PosPrinterPrintOptions);
        Py_VISIT(state->type_PosPrinterReleaseDeviceRequestedEventArgs);
        Py_VISIT(state->type_PosPrinterStatus);
        Py_VISIT(state->type_PosPrinterStatusUpdatedEventArgs);
        Py_VISIT(state->type_ReceiptPrintJob);
        Py_VISIT(state->type_ReceiptPrinterCapabilities);
        Py_VISIT(state->type_SlipPrintJob);
        Py_VISIT(state->type_SlipPrinterCapabilities);
        Py_VISIT(state->type_UnifiedPosErrorData);
        Py_VISIT(state->type_ICashDrawerEventSourceEventArgs);
        Py_VISIT(state->type_ICommonClaimedPosPrinterStation);
        Py_VISIT(state->type_ICommonPosPrintStationCapabilities);
        Py_VISIT(state->type_ICommonReceiptSlipCapabilities);
        Py_VISIT(state->type_IPosPrinterJob);
        Py_VISIT(state->type_IReceiptOrSlipJob);
        Py_VISIT(state->type_SizeUInt32);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_BarcodeScannerStatus);
        Py_CLEAR(state->type_BarcodeSymbologyDecodeLengthKind);
        Py_CLEAR(state->type_CashDrawerStatusKind);
        Py_CLEAR(state->type_LineDisplayCursorType);
        Py_CLEAR(state->type_LineDisplayDescriptorState);
        Py_CLEAR(state->type_LineDisplayHorizontalAlignment);
        Py_CLEAR(state->type_LineDisplayMarqueeFormat);
        Py_CLEAR(state->type_LineDisplayPowerStatus);
        Py_CLEAR(state->type_LineDisplayScrollDirection);
        Py_CLEAR(state->type_LineDisplayTextAttribute);
        Py_CLEAR(state->type_LineDisplayTextAttributeGranularity);
        Py_CLEAR(state->type_LineDisplayVerticalAlignment);
        Py_CLEAR(state->type_MagneticStripeReaderAuthenticationLevel);
        Py_CLEAR(state->type_MagneticStripeReaderAuthenticationProtocol);
        Py_CLEAR(state->type_MagneticStripeReaderErrorReportingType);
        Py_CLEAR(state->type_MagneticStripeReaderStatus);
        Py_CLEAR(state->type_MagneticStripeReaderTrackErrorType);
        Py_CLEAR(state->type_MagneticStripeReaderTrackIds);
        Py_CLEAR(state->type_PosConnectionTypes);
        Py_CLEAR(state->type_PosPrinterAlignment);
        Py_CLEAR(state->type_PosPrinterBarcodeTextPosition);
        Py_CLEAR(state->type_PosPrinterCartridgeSensors);
        Py_CLEAR(state->type_PosPrinterColorCapabilities);
        Py_CLEAR(state->type_PosPrinterColorCartridge);
        Py_CLEAR(state->type_PosPrinterLineDirection);
        Py_CLEAR(state->type_PosPrinterLineStyle);
        Py_CLEAR(state->type_PosPrinterMapMode);
        Py_CLEAR(state->type_PosPrinterMarkFeedCapabilities);
        Py_CLEAR(state->type_PosPrinterMarkFeedKind);
        Py_CLEAR(state->type_PosPrinterPrintSide);
        Py_CLEAR(state->type_PosPrinterRotation);
        Py_CLEAR(state->type_PosPrinterRuledLineCapabilities);
        Py_CLEAR(state->type_PosPrinterStatusKind);
        Py_CLEAR(state->type_UnifiedPosErrorReason);
        Py_CLEAR(state->type_UnifiedPosErrorSeverity);
        Py_CLEAR(state->type_UnifiedPosHealthCheckLevel);
        Py_CLEAR(state->type_UnifiedPosPowerReportingType);
        Py_CLEAR(state->type_BarcodeScanner);
        Py_CLEAR(state->type_BarcodeScannerCapabilities);
        Py_CLEAR(state->type_BarcodeScannerDataReceivedEventArgs);
        Py_CLEAR(state->type_BarcodeScannerErrorOccurredEventArgs);
        Py_CLEAR(state->type_BarcodeScannerImagePreviewReceivedEventArgs);
        Py_CLEAR(state->type_BarcodeScannerReport);
        Py_CLEAR(state->type_BarcodeScannerStatusUpdatedEventArgs);
        Py_CLEAR(state->type_BarcodeSymbologies);
        Py_CLEAR(state->type_BarcodeSymbologyAttributes);
        Py_CLEAR(state->type_CashDrawer);
        Py_CLEAR(state->type_CashDrawerCapabilities);
        Py_CLEAR(state->type_CashDrawerCloseAlarm);
        Py_CLEAR(state->type_CashDrawerClosedEventArgs);
        Py_CLEAR(state->type_CashDrawerEventSource);
        Py_CLEAR(state->type_CashDrawerOpenedEventArgs);
        Py_CLEAR(state->type_CashDrawerStatus);
        Py_CLEAR(state->type_CashDrawerStatusUpdatedEventArgs);
        Py_CLEAR(state->type_ClaimedBarcodeScanner);
        Py_CLEAR(state->type_ClaimedBarcodeScannerClosedEventArgs);
        Py_CLEAR(state->type_ClaimedCashDrawer);
        Py_CLEAR(state->type_ClaimedCashDrawerClosedEventArgs);
        Py_CLEAR(state->type_ClaimedJournalPrinter);
        Py_CLEAR(state->type_ClaimedLineDisplay);
        Py_CLEAR(state->type_ClaimedLineDisplayClosedEventArgs);
        Py_CLEAR(state->type_ClaimedMagneticStripeReader);
        Py_CLEAR(state->type_ClaimedMagneticStripeReaderClosedEventArgs);
        Py_CLEAR(state->type_ClaimedPosPrinter);
        Py_CLEAR(state->type_ClaimedPosPrinterClosedEventArgs);
        Py_CLEAR(state->type_ClaimedReceiptPrinter);
        Py_CLEAR(state->type_ClaimedSlipPrinter);
        Py_CLEAR(state->type_JournalPrintJob);
        Py_CLEAR(state->type_JournalPrinterCapabilities);
        Py_CLEAR(state->type_LineDisplay);
        Py_CLEAR(state->type_LineDisplayAttributes);
        Py_CLEAR(state->type_LineDisplayCapabilities);
        Py_CLEAR(state->type_LineDisplayCursor);
        Py_CLEAR(state->type_LineDisplayCursorAttributes);
        Py_CLEAR(state->type_LineDisplayCustomGlyphs);
        Py_CLEAR(state->type_LineDisplayMarquee);
        Py_CLEAR(state->type_LineDisplayStatisticsCategorySelector);
        Py_CLEAR(state->type_LineDisplayStatusUpdatedEventArgs);
        Py_CLEAR(state->type_LineDisplayStoredBitmap);
        Py_CLEAR(state->type_LineDisplayWindow);
        Py_CLEAR(state->type_MagneticStripeReader);
        Py_CLEAR(state->type_MagneticStripeReaderAamvaCardDataReceivedEventArgs);
        Py_CLEAR(state->type_MagneticStripeReaderBankCardDataReceivedEventArgs);
        Py_CLEAR(state->type_MagneticStripeReaderCapabilities);
        Py_CLEAR(state->type_MagneticStripeReaderCardTypes);
        Py_CLEAR(state->type_MagneticStripeReaderEncryptionAlgorithms);
        Py_CLEAR(state->type_MagneticStripeReaderErrorOccurredEventArgs);
        Py_CLEAR(state->type_MagneticStripeReaderReport);
        Py_CLEAR(state->type_MagneticStripeReaderStatusUpdatedEventArgs);
        Py_CLEAR(state->type_MagneticStripeReaderTrackData);
        Py_CLEAR(state->type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs);
        Py_CLEAR(state->type_PosPrinter);
        Py_CLEAR(state->type_PosPrinterCapabilities);
        Py_CLEAR(state->type_PosPrinterCharacterSetIds);
        Py_CLEAR(state->type_PosPrinterFontProperty);
        Py_CLEAR(state->type_PosPrinterPrintOptions);
        Py_CLEAR(state->type_PosPrinterReleaseDeviceRequestedEventArgs);
        Py_CLEAR(state->type_PosPrinterStatus);
        Py_CLEAR(state->type_PosPrinterStatusUpdatedEventArgs);
        Py_CLEAR(state->type_ReceiptPrintJob);
        Py_CLEAR(state->type_ReceiptPrinterCapabilities);
        Py_CLEAR(state->type_SlipPrintJob);
        Py_CLEAR(state->type_SlipPrinterCapabilities);
        Py_CLEAR(state->type_UnifiedPosErrorData);
        Py_CLEAR(state->type_ICashDrawerEventSourceEventArgs);
        Py_CLEAR(state->type_ICommonClaimedPosPrinterStation);
        Py_CLEAR(state->type_ICommonPosPrintStationCapabilities);
        Py_CLEAR(state->type_ICommonReceiptSlipCapabilities);
        Py_CLEAR(state->type_IPosPrinterJob);
        Py_CLEAR(state->type_IReceiptOrSlipJob);
        Py_CLEAR(state->type_SizeUInt32);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_PointOfService",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::PointOfService

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_PointOfService(void) noexcept
{
    using namespace py::cpp::Windows::Devices::PointOfService;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_BarcodeScanner = py::register_python_type(module.get(), type_name_BarcodeScanner, &type_spec_BarcodeScanner, bases.get(), nullptr);
    if (!state->type_BarcodeScanner)
    {
        return nullptr;
    }

    state->type_BarcodeScannerCapabilities = py::register_python_type(module.get(), type_name_BarcodeScannerCapabilities, &type_spec_BarcodeScannerCapabilities, bases.get(), nullptr);
    if (!state->type_BarcodeScannerCapabilities)
    {
        return nullptr;
    }

    state->type_BarcodeScannerDataReceivedEventArgs = py::register_python_type(module.get(), type_name_BarcodeScannerDataReceivedEventArgs, &type_spec_BarcodeScannerDataReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_BarcodeScannerDataReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_BarcodeScannerErrorOccurredEventArgs = py::register_python_type(module.get(), type_name_BarcodeScannerErrorOccurredEventArgs, &type_spec_BarcodeScannerErrorOccurredEventArgs, bases.get(), nullptr);
    if (!state->type_BarcodeScannerErrorOccurredEventArgs)
    {
        return nullptr;
    }

    state->type_BarcodeScannerImagePreviewReceivedEventArgs = py::register_python_type(module.get(), type_name_BarcodeScannerImagePreviewReceivedEventArgs, &type_spec_BarcodeScannerImagePreviewReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_BarcodeScannerImagePreviewReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_BarcodeScannerReport = py::register_python_type(module.get(), type_name_BarcodeScannerReport, &type_spec_BarcodeScannerReport, bases.get(), nullptr);
    if (!state->type_BarcodeScannerReport)
    {
        return nullptr;
    }

    state->type_BarcodeScannerStatusUpdatedEventArgs = py::register_python_type(module.get(), type_name_BarcodeScannerStatusUpdatedEventArgs, &type_spec_BarcodeScannerStatusUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_BarcodeScannerStatusUpdatedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_BarcodeSymbologies_Meta{PyType_FromSpec(&type_spec_BarcodeSymbologies_Meta)};
    if (!type_BarcodeSymbologies_Meta)
    {
        return nullptr;
    }

    state->type_BarcodeSymbologies = py::register_python_type(module.get(), type_name_BarcodeSymbologies, &type_spec_BarcodeSymbologies, nullptr, reinterpret_cast<PyTypeObject*>(type_BarcodeSymbologies_Meta.get()));
    if (!state->type_BarcodeSymbologies)
    {
        return nullptr;
    }

    state->type_BarcodeSymbologyAttributes = py::register_python_type(module.get(), type_name_BarcodeSymbologyAttributes, &type_spec_BarcodeSymbologyAttributes, bases.get(), nullptr);
    if (!state->type_BarcodeSymbologyAttributes)
    {
        return nullptr;
    }

    state->type_CashDrawer = py::register_python_type(module.get(), type_name_CashDrawer, &type_spec_CashDrawer, bases.get(), nullptr);
    if (!state->type_CashDrawer)
    {
        return nullptr;
    }

    state->type_CashDrawerCapabilities = py::register_python_type(module.get(), type_name_CashDrawerCapabilities, &type_spec_CashDrawerCapabilities, bases.get(), nullptr);
    if (!state->type_CashDrawerCapabilities)
    {
        return nullptr;
    }

    state->type_CashDrawerCloseAlarm = py::register_python_type(module.get(), type_name_CashDrawerCloseAlarm, &type_spec_CashDrawerCloseAlarm, bases.get(), nullptr);
    if (!state->type_CashDrawerCloseAlarm)
    {
        return nullptr;
    }

    state->type_CashDrawerClosedEventArgs = py::register_python_type(module.get(), type_name_CashDrawerClosedEventArgs, &type_spec_CashDrawerClosedEventArgs, bases.get(), nullptr);
    if (!state->type_CashDrawerClosedEventArgs)
    {
        return nullptr;
    }

    state->type_CashDrawerEventSource = py::register_python_type(module.get(), type_name_CashDrawerEventSource, &type_spec_CashDrawerEventSource, bases.get(), nullptr);
    if (!state->type_CashDrawerEventSource)
    {
        return nullptr;
    }

    state->type_CashDrawerOpenedEventArgs = py::register_python_type(module.get(), type_name_CashDrawerOpenedEventArgs, &type_spec_CashDrawerOpenedEventArgs, bases.get(), nullptr);
    if (!state->type_CashDrawerOpenedEventArgs)
    {
        return nullptr;
    }

    state->type_CashDrawerStatus = py::register_python_type(module.get(), type_name_CashDrawerStatus, &type_spec_CashDrawerStatus, bases.get(), nullptr);
    if (!state->type_CashDrawerStatus)
    {
        return nullptr;
    }

    state->type_CashDrawerStatusUpdatedEventArgs = py::register_python_type(module.get(), type_name_CashDrawerStatusUpdatedEventArgs, &type_spec_CashDrawerStatusUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_CashDrawerStatusUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedBarcodeScanner = py::register_python_type(module.get(), type_name_ClaimedBarcodeScanner, &type_spec_ClaimedBarcodeScanner, bases.get(), nullptr);
    if (!state->type_ClaimedBarcodeScanner)
    {
        return nullptr;
    }

    state->type_ClaimedBarcodeScannerClosedEventArgs = py::register_python_type(module.get(), type_name_ClaimedBarcodeScannerClosedEventArgs, &type_spec_ClaimedBarcodeScannerClosedEventArgs, bases.get(), nullptr);
    if (!state->type_ClaimedBarcodeScannerClosedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedCashDrawer = py::register_python_type(module.get(), type_name_ClaimedCashDrawer, &type_spec_ClaimedCashDrawer, bases.get(), nullptr);
    if (!state->type_ClaimedCashDrawer)
    {
        return nullptr;
    }

    state->type_ClaimedCashDrawerClosedEventArgs = py::register_python_type(module.get(), type_name_ClaimedCashDrawerClosedEventArgs, &type_spec_ClaimedCashDrawerClosedEventArgs, bases.get(), nullptr);
    if (!state->type_ClaimedCashDrawerClosedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedJournalPrinter = py::register_python_type(module.get(), type_name_ClaimedJournalPrinter, &type_spec_ClaimedJournalPrinter, bases.get(), nullptr);
    if (!state->type_ClaimedJournalPrinter)
    {
        return nullptr;
    }

    state->type_ClaimedLineDisplay = py::register_python_type(module.get(), type_name_ClaimedLineDisplay, &type_spec_ClaimedLineDisplay, bases.get(), nullptr);
    if (!state->type_ClaimedLineDisplay)
    {
        return nullptr;
    }

    state->type_ClaimedLineDisplayClosedEventArgs = py::register_python_type(module.get(), type_name_ClaimedLineDisplayClosedEventArgs, &type_spec_ClaimedLineDisplayClosedEventArgs, bases.get(), nullptr);
    if (!state->type_ClaimedLineDisplayClosedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedMagneticStripeReader = py::register_python_type(module.get(), type_name_ClaimedMagneticStripeReader, &type_spec_ClaimedMagneticStripeReader, bases.get(), nullptr);
    if (!state->type_ClaimedMagneticStripeReader)
    {
        return nullptr;
    }

    state->type_ClaimedMagneticStripeReaderClosedEventArgs = py::register_python_type(module.get(), type_name_ClaimedMagneticStripeReaderClosedEventArgs, &type_spec_ClaimedMagneticStripeReaderClosedEventArgs, bases.get(), nullptr);
    if (!state->type_ClaimedMagneticStripeReaderClosedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedPosPrinter = py::register_python_type(module.get(), type_name_ClaimedPosPrinter, &type_spec_ClaimedPosPrinter, bases.get(), nullptr);
    if (!state->type_ClaimedPosPrinter)
    {
        return nullptr;
    }

    state->type_ClaimedPosPrinterClosedEventArgs = py::register_python_type(module.get(), type_name_ClaimedPosPrinterClosedEventArgs, &type_spec_ClaimedPosPrinterClosedEventArgs, bases.get(), nullptr);
    if (!state->type_ClaimedPosPrinterClosedEventArgs)
    {
        return nullptr;
    }

    state->type_ClaimedReceiptPrinter = py::register_python_type(module.get(), type_name_ClaimedReceiptPrinter, &type_spec_ClaimedReceiptPrinter, bases.get(), nullptr);
    if (!state->type_ClaimedReceiptPrinter)
    {
        return nullptr;
    }

    state->type_ClaimedSlipPrinter = py::register_python_type(module.get(), type_name_ClaimedSlipPrinter, &type_spec_ClaimedSlipPrinter, bases.get(), nullptr);
    if (!state->type_ClaimedSlipPrinter)
    {
        return nullptr;
    }

    state->type_JournalPrintJob = py::register_python_type(module.get(), type_name_JournalPrintJob, &type_spec_JournalPrintJob, bases.get(), nullptr);
    if (!state->type_JournalPrintJob)
    {
        return nullptr;
    }

    state->type_JournalPrinterCapabilities = py::register_python_type(module.get(), type_name_JournalPrinterCapabilities, &type_spec_JournalPrinterCapabilities, bases.get(), nullptr);
    if (!state->type_JournalPrinterCapabilities)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineDisplay_Meta{PyType_FromSpec(&type_spec_LineDisplay_Meta)};
    if (!type_LineDisplay_Meta)
    {
        return nullptr;
    }

    state->type_LineDisplay = py::register_python_type(module.get(), type_name_LineDisplay, &type_spec_LineDisplay, bases.get(), reinterpret_cast<PyTypeObject*>(type_LineDisplay_Meta.get()));
    if (!state->type_LineDisplay)
    {
        return nullptr;
    }

    state->type_LineDisplayAttributes = py::register_python_type(module.get(), type_name_LineDisplayAttributes, &type_spec_LineDisplayAttributes, bases.get(), nullptr);
    if (!state->type_LineDisplayAttributes)
    {
        return nullptr;
    }

    state->type_LineDisplayCapabilities = py::register_python_type(module.get(), type_name_LineDisplayCapabilities, &type_spec_LineDisplayCapabilities, bases.get(), nullptr);
    if (!state->type_LineDisplayCapabilities)
    {
        return nullptr;
    }

    state->type_LineDisplayCursor = py::register_python_type(module.get(), type_name_LineDisplayCursor, &type_spec_LineDisplayCursor, bases.get(), nullptr);
    if (!state->type_LineDisplayCursor)
    {
        return nullptr;
    }

    state->type_LineDisplayCursorAttributes = py::register_python_type(module.get(), type_name_LineDisplayCursorAttributes, &type_spec_LineDisplayCursorAttributes, bases.get(), nullptr);
    if (!state->type_LineDisplayCursorAttributes)
    {
        return nullptr;
    }

    state->type_LineDisplayCustomGlyphs = py::register_python_type(module.get(), type_name_LineDisplayCustomGlyphs, &type_spec_LineDisplayCustomGlyphs, bases.get(), nullptr);
    if (!state->type_LineDisplayCustomGlyphs)
    {
        return nullptr;
    }

    state->type_LineDisplayMarquee = py::register_python_type(module.get(), type_name_LineDisplayMarquee, &type_spec_LineDisplayMarquee, bases.get(), nullptr);
    if (!state->type_LineDisplayMarquee)
    {
        return nullptr;
    }

    state->type_LineDisplayStatisticsCategorySelector = py::register_python_type(module.get(), type_name_LineDisplayStatisticsCategorySelector, &type_spec_LineDisplayStatisticsCategorySelector, bases.get(), nullptr);
    if (!state->type_LineDisplayStatisticsCategorySelector)
    {
        return nullptr;
    }

    state->type_LineDisplayStatusUpdatedEventArgs = py::register_python_type(module.get(), type_name_LineDisplayStatusUpdatedEventArgs, &type_spec_LineDisplayStatusUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_LineDisplayStatusUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_LineDisplayStoredBitmap = py::register_python_type(module.get(), type_name_LineDisplayStoredBitmap, &type_spec_LineDisplayStoredBitmap, bases.get(), nullptr);
    if (!state->type_LineDisplayStoredBitmap)
    {
        return nullptr;
    }

    state->type_LineDisplayWindow = py::register_python_type(module.get(), type_name_LineDisplayWindow, &type_spec_LineDisplayWindow, bases.get(), nullptr);
    if (!state->type_LineDisplayWindow)
    {
        return nullptr;
    }

    state->type_MagneticStripeReader = py::register_python_type(module.get(), type_name_MagneticStripeReader, &type_spec_MagneticStripeReader, bases.get(), nullptr);
    if (!state->type_MagneticStripeReader)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderAamvaCardDataReceivedEventArgs = py::register_python_type(module.get(), type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs, &type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderAamvaCardDataReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderBankCardDataReceivedEventArgs = py::register_python_type(module.get(), type_name_MagneticStripeReaderBankCardDataReceivedEventArgs, &type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderBankCardDataReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderCapabilities = py::register_python_type(module.get(), type_name_MagneticStripeReaderCapabilities, &type_spec_MagneticStripeReaderCapabilities, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderCapabilities)
    {
        return nullptr;
    }

    py::pyobj_handle type_MagneticStripeReaderCardTypes_Meta{PyType_FromSpec(&type_spec_MagneticStripeReaderCardTypes_Meta)};
    if (!type_MagneticStripeReaderCardTypes_Meta)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderCardTypes = py::register_python_type(module.get(), type_name_MagneticStripeReaderCardTypes, &type_spec_MagneticStripeReaderCardTypes, nullptr, reinterpret_cast<PyTypeObject*>(type_MagneticStripeReaderCardTypes_Meta.get()));
    if (!state->type_MagneticStripeReaderCardTypes)
    {
        return nullptr;
    }

    py::pyobj_handle type_MagneticStripeReaderEncryptionAlgorithms_Meta{PyType_FromSpec(&type_spec_MagneticStripeReaderEncryptionAlgorithms_Meta)};
    if (!type_MagneticStripeReaderEncryptionAlgorithms_Meta)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderEncryptionAlgorithms = py::register_python_type(module.get(), type_name_MagneticStripeReaderEncryptionAlgorithms, &type_spec_MagneticStripeReaderEncryptionAlgorithms, nullptr, reinterpret_cast<PyTypeObject*>(type_MagneticStripeReaderEncryptionAlgorithms_Meta.get()));
    if (!state->type_MagneticStripeReaderEncryptionAlgorithms)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderErrorOccurredEventArgs = py::register_python_type(module.get(), type_name_MagneticStripeReaderErrorOccurredEventArgs, &type_spec_MagneticStripeReaderErrorOccurredEventArgs, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderErrorOccurredEventArgs)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderReport = py::register_python_type(module.get(), type_name_MagneticStripeReaderReport, &type_spec_MagneticStripeReaderReport, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderReport)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderStatusUpdatedEventArgs = py::register_python_type(module.get(), type_name_MagneticStripeReaderStatusUpdatedEventArgs, &type_spec_MagneticStripeReaderStatusUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderStatusUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderTrackData = py::register_python_type(module.get(), type_name_MagneticStripeReaderTrackData, &type_spec_MagneticStripeReaderTrackData, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderTrackData)
    {
        return nullptr;
    }

    state->type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = py::register_python_type(module.get(), type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, &type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_PosPrinter = py::register_python_type(module.get(), type_name_PosPrinter, &type_spec_PosPrinter, bases.get(), nullptr);
    if (!state->type_PosPrinter)
    {
        return nullptr;
    }

    state->type_PosPrinterCapabilities = py::register_python_type(module.get(), type_name_PosPrinterCapabilities, &type_spec_PosPrinterCapabilities, bases.get(), nullptr);
    if (!state->type_PosPrinterCapabilities)
    {
        return nullptr;
    }

    py::pyobj_handle type_PosPrinterCharacterSetIds_Meta{PyType_FromSpec(&type_spec_PosPrinterCharacterSetIds_Meta)};
    if (!type_PosPrinterCharacterSetIds_Meta)
    {
        return nullptr;
    }

    state->type_PosPrinterCharacterSetIds = py::register_python_type(module.get(), type_name_PosPrinterCharacterSetIds, &type_spec_PosPrinterCharacterSetIds, nullptr, reinterpret_cast<PyTypeObject*>(type_PosPrinterCharacterSetIds_Meta.get()));
    if (!state->type_PosPrinterCharacterSetIds)
    {
        return nullptr;
    }

    state->type_PosPrinterFontProperty = py::register_python_type(module.get(), type_name_PosPrinterFontProperty, &type_spec_PosPrinterFontProperty, bases.get(), nullptr);
    if (!state->type_PosPrinterFontProperty)
    {
        return nullptr;
    }

    state->type_PosPrinterPrintOptions = py::register_python_type(module.get(), type_name_PosPrinterPrintOptions, &type_spec_PosPrinterPrintOptions, bases.get(), nullptr);
    if (!state->type_PosPrinterPrintOptions)
    {
        return nullptr;
    }

    state->type_PosPrinterReleaseDeviceRequestedEventArgs = py::register_python_type(module.get(), type_name_PosPrinterReleaseDeviceRequestedEventArgs, &type_spec_PosPrinterReleaseDeviceRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PosPrinterReleaseDeviceRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_PosPrinterStatus = py::register_python_type(module.get(), type_name_PosPrinterStatus, &type_spec_PosPrinterStatus, bases.get(), nullptr);
    if (!state->type_PosPrinterStatus)
    {
        return nullptr;
    }

    state->type_PosPrinterStatusUpdatedEventArgs = py::register_python_type(module.get(), type_name_PosPrinterStatusUpdatedEventArgs, &type_spec_PosPrinterStatusUpdatedEventArgs, bases.get(), nullptr);
    if (!state->type_PosPrinterStatusUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_ReceiptPrintJob = py::register_python_type(module.get(), type_name_ReceiptPrintJob, &type_spec_ReceiptPrintJob, bases.get(), nullptr);
    if (!state->type_ReceiptPrintJob)
    {
        return nullptr;
    }

    state->type_ReceiptPrinterCapabilities = py::register_python_type(module.get(), type_name_ReceiptPrinterCapabilities, &type_spec_ReceiptPrinterCapabilities, bases.get(), nullptr);
    if (!state->type_ReceiptPrinterCapabilities)
    {
        return nullptr;
    }

    state->type_SlipPrintJob = py::register_python_type(module.get(), type_name_SlipPrintJob, &type_spec_SlipPrintJob, bases.get(), nullptr);
    if (!state->type_SlipPrintJob)
    {
        return nullptr;
    }

    state->type_SlipPrinterCapabilities = py::register_python_type(module.get(), type_name_SlipPrinterCapabilities, &type_spec_SlipPrinterCapabilities, bases.get(), nullptr);
    if (!state->type_SlipPrinterCapabilities)
    {
        return nullptr;
    }

    state->type_UnifiedPosErrorData = py::register_python_type(module.get(), type_name_UnifiedPosErrorData, &type_spec_UnifiedPosErrorData, bases.get(), nullptr);
    if (!state->type_UnifiedPosErrorData)
    {
        return nullptr;
    }

    state->type_ICashDrawerEventSourceEventArgs = py::register_python_type(module.get(), type_name_ICashDrawerEventSourceEventArgs, &type_spec_ICashDrawerEventSourceEventArgs, bases.get(), nullptr);
    if (!state->type_ICashDrawerEventSourceEventArgs)
    {
        return nullptr;
    }

    state->type_ICommonClaimedPosPrinterStation = py::register_python_type(module.get(), type_name_ICommonClaimedPosPrinterStation, &type_spec_ICommonClaimedPosPrinterStation, bases.get(), nullptr);
    if (!state->type_ICommonClaimedPosPrinterStation)
    {
        return nullptr;
    }

    state->type_ICommonPosPrintStationCapabilities = py::register_python_type(module.get(), type_name_ICommonPosPrintStationCapabilities, &type_spec_ICommonPosPrintStationCapabilities, bases.get(), nullptr);
    if (!state->type_ICommonPosPrintStationCapabilities)
    {
        return nullptr;
    }

    state->type_ICommonReceiptSlipCapabilities = py::register_python_type(module.get(), type_name_ICommonReceiptSlipCapabilities, &type_spec_ICommonReceiptSlipCapabilities, bases.get(), nullptr);
    if (!state->type_ICommonReceiptSlipCapabilities)
    {
        return nullptr;
    }

    state->type_IPosPrinterJob = py::register_python_type(module.get(), type_name_IPosPrinterJob, &type_spec_IPosPrinterJob, bases.get(), nullptr);
    if (!state->type_IPosPrinterJob)
    {
        return nullptr;
    }

    state->type_IReceiptOrSlipJob = py::register_python_type(module.get(), type_name_IReceiptOrSlipJob, &type_spec_IReceiptOrSlipJob, bases.get(), nullptr);
    if (!state->type_IReceiptOrSlipJob)
    {
        return nullptr;
    }

    state->type_SizeUInt32 = py::register_python_type(module.get(), type_name_SizeUInt32, &type_spec_SizeUInt32, bases.get(), nullptr);
    if (!state->type_SizeUInt32)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeSymbologyDecodeLengthKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerStatusKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerStatusKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayCursorType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayCursorType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayDescriptorState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayHorizontalAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayMarqueeFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayPowerStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayPowerStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayPowerStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayScrollDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayTextAttribute;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayTextAttributeGranularity>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayTextAttributeGranularity;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayTextAttributeGranularity is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayVerticalAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAuthenticationLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderAuthenticationLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderAuthenticationLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAuthenticationProtocol>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderAuthenticationProtocol;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderAuthenticationProtocol is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderErrorReportingType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackErrorType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderTrackErrorType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackErrorType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderTrackIds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosConnectionTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosConnectionTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosConnectionTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterBarcodeTextPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterCartridgeSensors>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterCartridgeSensors;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterCartridgeSensors is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterColorCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterColorCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterColorCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterColorCartridge;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterLineDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterLineDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterLineStyle;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterLineStyle is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterMapMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterMapMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterMapMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterMarkFeedCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterMarkFeedKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintSide>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterPrintSide;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterPrintSide is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterRotation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterRotation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterRotation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterRuledLineCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterRuledLineCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterRuledLineCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterStatusKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterStatusKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnifiedPosErrorReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnifiedPosErrorSeverity;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnifiedPosHealthCheckLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::PointOfService::UnifiedPosPowerReportingType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnifiedPosPowerReportingType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::UnifiedPosPowerReportingType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScanner;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScanner is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerErrorOccurredEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerImagePreviewReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerStatusUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeSymbologies;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeSymbologies is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeSymbologyAttributes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerCloseAlarm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerEventSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerEventSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerOpenedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CashDrawerStatusUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedBarcodeScanner;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedBarcodeScannerClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedCashDrawer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedCashDrawer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedCashDrawerClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedJournalPrinter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedLineDisplay;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedLineDisplay is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedLineDisplayClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedMagneticStripeReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedMagneticStripeReaderClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedPosPrinter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedPosPrinter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedPosPrinterClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedReceiptPrinter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ClaimedSlipPrinter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JournalPrintJob;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::JournalPrintJob is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JournalPrinterCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplay>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplay;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplay is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayAttributes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayAttributes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayCursor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayCursor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayCursorAttributes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayCustomGlyphs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayMarquee;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayMarquee is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayStatisticsCategorySelector;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayStatusUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayStoredBitmap;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineDisplayWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::LineDisplayWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderAamvaCardDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderBankCardDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderCardTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderEncryptionAlgorithms;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderErrorOccurredEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderStatusUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderTrackData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterCharacterSetIds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterFontProperty;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterFontProperty is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterPrintOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterReleaseDeviceRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PosPrinterStatusUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReceiptPrintJob;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ReceiptPrintJob is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReceiptPrinterCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SlipPrintJob;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::SlipPrintJob is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SlipPrinterCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnifiedPosErrorData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::UnifiedPosErrorData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICashDrawerEventSourceEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICommonClaimedPosPrinterStation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICommonPosPrintStationCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICommonReceiptSlipCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPosPrinterJob;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::IPosPrinterJob is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IReceiptOrSlipJob;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SizeUInt32>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::PointOfService;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::PointOfService");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SizeUInt32;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::PointOfService::SizeUInt32 is not registered");
        return nullptr;
    }

    return python_type;
}
